Q：进程和线程的区别是什么？要有深度
A：一个进程是一个独立的运行环境，是系统进行资源分配和管理的基本单位
     线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。
	 不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间

Q：线程的启动方式是start还是run？
A：start是启动线程，run是普通的调用run方法。
	 
Q：创建线程有几种不同的方式？你喜欢哪一种？为什么？
A：有三种方式可以用来创建线程：
		继承Thread类
		实现Runnable接口
		应用程序可以使用Executor框架来创建线程池

		实现Runnable接口比继承Thread类所具有的优势：
			1）：适合多个相同的程序代码的线程去处理同一个资源
			2）：可以避免java中的单继承的限制
			3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
		同时，线程池也是非常高效的，很容易实现和使用。

		main方法其实也是一个线程。在java中所有的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。
		在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，
		实际上都会启动一个jvm，每一个jvm实现在就是在操作系统中启动了一个进程。
   
Q：线程的五种状态
A：1、新建状态（New）：新创建了一个线程对象。
	2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
	3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
	4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
		（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。
		（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
		（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
	5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

Q：Java等待/通知机制
A：都是Object的方法，必须在同步代码中使用（为了防止在进入wait过程中就调用了notify，导致一直阻塞，等待和通知这两个操作必须互斥）
	是指一个线程A调用了对象O的wait()方法释放了锁并进入等待阻塞状态，另一个线程B调用了对象O的notify()或者notifyAll()方法，
		线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。

	典型用法：分为等待方（消费者）和通知方（生产者）
		等待方遵循以下原则：1.获取对象O的锁
							2.循环判断条件是否满足，如果不满足，调用对象O的wait方法，会释放锁并进入等待阻塞，被通知后仍要检查条件。
							3.条件满足则执行对应的逻辑
		通知方遵循以下原则：1.获得对象O的锁
							2.改变条件，以满足等待方的需求
							3.通知一个或所有等待在对象O上的线程，在同步代码块执行完之后释放锁，被唤醒的线程将竞争对象O的锁
	
	
Q：线程调度
	线程优先级：每一个线程都有优先级，默认继承父线程的优先级，可通过setPriority方法设置。每当线程调度器有机会选择新线程时，
				它首先选择较高优先级的线程，但线程优先级高度依赖操作系统，要看宿主机平台的线程实现机制。
			   
	线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，
				就转为就绪（Runnable）状态。sleep()平台移植性好。
	
	线程让步：Thread.yield() 方法，将当前正在执行的线程对象转为就绪状态，把执行机会让给相同或者更高优先级的线程，很可能没用，
			因为当前线程对象有可能又被线程调度器选中运行。
        
		sleep()和yield()的区别:
			sleep()使当前线程进入阻塞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；
			yield()只是使当前线程重新回到就绪状态，所以执行yield()的线程有可能在进入到就绪状态后马上又被执行。
	
			为什么sleep和yield都是静态的：因为这两个方法都要在正在执行的线程上被调用，在等待状态的线程上调用这两个方法没有意义。
	
		sleep和wait的区别有：
			1，sleep是Thread类的静态方法，不涉及线程同步的概念；wait是Object的方法，实现等待/通知机制
			2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
			3，wait，notify和notifyAll只能在同步代码中（获得过锁）使用，而sleep可以在任何地方使用
				synchronized(x){
					x.notify()//或者x.wait()
				}
				
	线程加入：join()方法，等待调用者线程终止。在当前线程A中调用另一个线程B的b.join()方法，则线程A转入阻塞状态，
					直到线程B终止之后才从b.join()返回，线程A由阻塞转为就绪状态。另有超时特性，在给定的时间内线程B没有终止，也会从该方法返回。
					这个方法涉及了Java等待/通知机制。
			
	线程中断：interrupt()，只是设置了一个中断状态。
			如果因Object.wait, Thread.join和Thread.sleep三种方法导致了阻塞，则其中断状态将被清除，它还将收到一个InterruptedException异常
　　		要想结束进程最好的办法就是在线程类里面用以个boolean型共享变量来控制run()方法什么时候结束，run()方法一结束，该线程也就结束了。
	
	守护线程：通过调用setDaemon(true)将线程转为守护线程。其唯一用途是为其他线程提供服务，例如计时线程。
				    当只剩下守护线程时，虚拟机就立即退出，守护线程的finally块也不会执行。
			 
	处理未捕获异常的处理器：不被检测的异常会导致线程终止，在线程死亡之前，异常被传递到一个用于未捕获异常的处理器，
						   通过setUncaughtExceptionHandler方法来为线程安装一个处理器，默认为空。
						   
	线程组：如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。线程组是一个可以统一管理的线程集合。
		   ThreadGroup类实现了Thread.UncaughtExceptionHandler接口，按顺序选择下面一个操作：
				1.如果该线程组有父线程组，则调用父线程组的uncaughtException方法
				2.如果Thread.getDefaultExceptionHandler方法返回一个非空的处理器，则调用它
				3.如果Throwable是ThreadDeath的一个实例，什么都不做
				4.线程的名字以及Throwable的栈踪迹被输出到System.err上

   同步：两个或两个以上的线程需要共享同一数据的存取，可能会产生错误。这个情况成为竞争条件。

	main()函数即主函数，是一个前台线程，前台进程是程序中必须执行完成的，而后台线程则是java中所有前台结束后结束，不管有没有完成，后台线程主要用与内存分配等方面。                                                                                           
	前台线程和后台线程的区别和联系：
		1、后台线程不会阻止进程的终止。属于某个进程的所有前台线程都终止后，该进程就会被终止。所有剩余的后台线程都会停止且不会完成。
		2、可以在任何时候将前台线程修改为后台线程，方式是设置Thread.IsBackground 属性。
		3、不管是前台线程还是后台线程，如果线程内出现了异常，都会导致进程的终止。
		4、托管线程池中的线程都是后台线程，使用new Thread方式创建的线程默认都是前台线程。
	说明： 应用程序的主线程以及使用Thread构造的线程都默认为前台线程                       
		使用Thread建立的线程默认情况下是前台线程，在进程中，只要有一个前台线程未退出，进程就不会终止。
		主线程就是一个前台线程。而后台线程不管线程是否结束，只要所有的前台线程都退出（包括正常退出和异常退出）后，进程就会自动终止。
		一般后台线程用于处理时间较短的任务，如在一个Web服务器中可以利用后台线程来处理客户端发过来的请求信息。
		而前台线程一般用于处理需要长时间等待的任务，如在Web服务器中的监听客户端请求的程序，或是定时对某些系统资源进行扫描的程序
		
Q：锁的升级与对比
A：锁有4种状态，级别从低到高依次是无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。
		
		偏向锁：如果同一个线程经常要获得某个锁，为了让它获得锁的代价更低而引入偏向锁。偏向锁使用了一种等到竞争出现才释放锁的机制，
						当其他线程尝试竞争偏向锁时，持有偏向锁的线程才释放锁。
			原理：当一个线程访问同步代码块时并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，
						以后该线程在进入和退出同步代码块时不需要进行CAS操作来加锁和解锁。
			优点：加锁解锁不需要额外的消耗，和执行非同步方法相比差距很小。
			缺点：如果有线程来竞争锁，会带来额外的锁撤销的消耗。
			场景：适用于只有一个线程访问同步块
		
		轻量级锁：
			优点：竞争的线程不会阻塞
			缺点：如果始终竞争不到锁，线程执行一个忙循环（自旋），自旋避免了线程切换的开销，但是占用处理器的时间
			场景：追求响应时间，同步代码块执行速度非常快
		
		重量级锁：synchronized
			优点：线程竞争不使用自旋，不会消耗CPU
			缺点：线程阻塞，响应时间缓慢
			场景：追求吞吐量，同步代码块执行慢

Q：volatile关键字
A：volatile是轻量级的synchronized，可以保证下一个读取操作会在前一个写操作之后发生，这样从主内存加载到线程工作内存的值是最新的
		用volatile修饰后的变量不允许有不同于主内存区域的变量拷贝。任何线程中改变了它的值必须同步刷新回主内存，所有其他线程立即获取到了相同的值
		对于volatile修饰的变量，读取时JMM会把该线程对应的工作内存置为无效，然后从主内存读取。但是加载与修改变量的值和写入主内存等操作并不是原子性的，
			所以即使用了volatile修饰变量，仍存在并发的问题。

		关于jvm运行时内存分配：每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，
		首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程工作内存中，建立一个变量副本，
		之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），
		自动把线程变量副本的值回写到对象在堆中变量。
			
Q：synchronized关键字
A：我的理解
	 一、synchronized是重量级锁，可以用于创建代码块、修饰普通方法和静态方法
	 
	 二、创建代码块时需要指一个对象作为互斥体，如果是类的class实例，则锁的是该类的Class对象，相当于修饰静态方法。
				如果是一个对象，则锁的是该对象，相当于修饰普通方法
	 
	 三、一个类只有一个锁，一个对象也只有一个锁，它们互相不干扰
	 
	 四、当一个线程访问同步代码时，它首先必须得到锁，退出或抛出异常时必须释放锁。另一个线程再想访问该同步代码时会被阻塞，
				但是它可以访问非同步代码，当持有锁的线程释放锁之后会唤醒这个被阻塞的线程，对锁进行新的一轮竞争
				
	 五、本质是对一个对象的监视器monitor进行获取
	 
Q：Lock接口
A：显式地获取和释放锁。
		lock() 方法是平常使用得最多的一个方法，就是用来获取锁，如果锁已被其他线程获取，则进行等待，不可中断。
		tryLock() 尝试非阻塞地获取锁，立即返回true或者false，不可中断
		tryLock(long timeout, TimeUnit unit)，超时的获取锁，会响应中断，即在锁的获取过程中可以中断当前线程，它允许程序打破死锁。
		lockInterruptibly()，它相当于一个超时设为无限的tryLock(long timeout, TimeUnit unit)方法。
		
		
Q：线程池技术
A：在什么情况下使用线程池  1.单个任务处理的时间比较短 2.将需处理的任务的数量大 
	  好处 1.减少在创建和销毁线程上所花的时间以及系统资源的开销 
		     2.如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存以及”过度切换”。 
	ThreadPoolExecutor类是线程池的核心，继承自AbstractExecutorService，其实现了ExecutorService接口，其继承了Executor顶层接口。
		先看其构造方法，有七个参数
			corePoolSize：核心池的大小，在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，
								   当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。
			maximumPoolSize：线程池最大线程数。
			keepAliveTime：表示线程没有任务执行时最多保持多久时间再终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，
			                      keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize
			unit：参数keepAliveTime的时间单位，有7种取值，是在TimeUnit类中的7种静态属性，从天一直到纳秒
			workQueue：阻塞队列，用来存储等待执行的任务。
			                     一般使用LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE
								      和synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。
								 较少使用ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小和PriorityBlockingQueue
			threadFactory：线程工厂，主要用来创建线程
			handler：表示当拒绝处理任务时的策略，有四种取值：
			                    ThreadPoolExecutor.AbortPolicy 丢弃任务并抛出RejectedExecutionException异常、
								ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
								ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
								ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务

		不过不推荐直接使用ThreadPoolExecutor，而是通过Executors的几个静态方法来创建线程池，如果它提供的不满足使用，可以自己创建

		在ThreadPoolExecutor类中有几个非常重要的方法：
			execute() 方法实际上是接口Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，
							这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。
	  　　submit() 方法是在接口ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，
							在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，
							但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，
							会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。
			shutdown() 此时线程池不能够接受新的任务，它会等待所有任务执行完毕
			shutdownNow() 线程池不能接受新的任务，并且会去尝试终止正在执行的任务
			awaitTermination(timeout) 阻塞直到所有任务执行完，或者超时 
			
		重点是execute(Runnable)的执行步骤：
			   如果当前线程数小于核心线程池容量，则开启一个新线程并将该任务作为其第一个任务。
			   如果当前线程数大于等于核心线程池容量，就将该任务放进等待队列中，空下来的线程会从等待队列中取得任务来运行。
			   如果队列满了，则开启一个新的非核心线程处理它，此时总线程数不能超过设定的最大值。
			   如果开启非核心线程失败了，按照拒绝策略拒绝该任务。

Q：Callable、Future和FutureTask
A：创建线程的2种方式，一种是直接继承Thread，一种就是实现Runnable接口。这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。
      如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。
	  而自从Java 1.5开始，就提供了Callable和Future接口，通过它们可以在任务执行完毕之后得到任务执行结果。
	  
	  Callable是一个泛型接口，里面call()方法返回的类型就是传递进来的泛型。一般情况下是配合ExecutorService来使用的
	  
	  Future是异步计算的结果，对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果，get()会阻塞直到任务返回结果。
	  FutureTask实现了Runnable和Future接口，它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。

	Callable和Runnable的区别如下：
		I.Callable定义的方法是call，而Runnable定义的方法是run。
		II.Callable的call方法可以有返回值，而Runnable的run方法不能有返回值。
		III.Callable的call方法可抛出异常，而Runnable的run方法不能抛出异常。  
	  
Q：死锁的四个必要条件和如何处理死锁
A：死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
            这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：
				互斥条件：一个资源每次只能被一个进程使用。
				请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
				不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
				循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

	避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。

Q：如何确保线程安全，线程同步的方法，
A：确保线程安全：同步synchronized、使用原子类、实现并发锁、使用volatile关键字、使用不变类和线程安全类。
     同步的方法：用锁！
		
Q：sychronized和lock的区别      
A：Lock接口比同步代码块提供了更具扩展性的锁操作，允许更灵活的结构
		可以使锁更公平
		可以使线程在等待锁的时候响应中断
		可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间
		可以在不同的范围，以不同的顺序获取和释放锁

Q：Java内存模型与线程
A：JMM是共享内存模型，线程之间的通信是隐式的。
		所有变量（实例域、静态域和数组元素但不包括局部变量、方法参数和异常处理器参数，后者是线程私有的）存储在主内存中，每个线程都有
		一个私有的工作内存，工作内存中保存了该线程使用到的变量，是主内存的副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中
		进行，而不能直接操作主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量。
		
		工作内存是JMM的一个抽象概念，并不真实存在。
		JMM属于语言级的内存模型。
		
	线程A要和线程B通信的话，有两个步骤，先把线程A的工作内存A中更新过的共享变量刷新到主内存中去，然后线程B到主内存中读取这个共享变量到工作内存B中。
	
	内存间交互操作
	　　关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，
	    Java内存模型定义了以下八种操作来完成：

			lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
			unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
			read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
			load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
			use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
			assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
			store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
			write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。
			　　
		如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，
			就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，
			store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。
			Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

			不允许read和load、store和write操作之一单独出现
			不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
			不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
			一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
			一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
			如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
			如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
			对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

Q：为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume
A：因为该方法本质上是不安全的。停止一个线程将释放它已经锁定的所有监视器。
     如果以前受这些监视器保护的任何对象都处于一种不一致的状态，则损坏的对象将对其他线程可见，这有可能导致任意的行为

Q：ThreadLocal
A：与线程同步无关，并不是为了解决多线程共享变量问题！ 
      ThreadLocal类用来维护线程内部的局部变量。这些变量在多线程环境下访问时能保证各个线程里的变量相对独立于其他线程内的变量，
	      其中有一个静态内部类ThreadLocalMap(其类似于Map)，用键值对的形式存储每一个线程的变量副本，
	      ThreadLocalMap中元素的key为当前ThreadLocal对象，而value对应线程的变量副本，每个线程可能存在多个ThreadLocal。
		  ThreadLocal提供了get、set、initialValue等方法来操作这个map
		  
	  如果ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并
      发访问问题。  
Q：垃圾回收GC
A：关于GC有三个问题要考虑
		1.哪些内存需要回收？
			总结：从gc root开始搜索找不到的对象，而且经过一次标记、清理，仍然没有复活的对象。
			主要的区域是Java堆和方法区的内存，堆中放着几乎所有的对象实例。方法区回收废弃的常量和无用的类。
			
			引用计数算法，最简单并且效率高的判断方法，但有一个很大的问题就是它很难解决对象之间的互相循环引用。
			
			可达性分析算法，现在的主流，将一系列GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到
				   GC Roots没有任何引用链相连即从GC Roots到这个对象不可达时，则此对象是不可用的，可回收。
				   可作为GC Roots的对象包括：方法区中类静态属性或常量引用的对象（全局性的引用）、
				                                             虚拟机栈（栈帧中的本地变量表）中引用的对象、
															 本地方法栈中JNI引用的对象
			
			关于引用：强引用，如Object obj = new Object();只要强引用还在，就永远不会回收被引用的对象。
							软引用，描述一些还有用但非必需的对象，在系统将要发生内存溢出之前，会将软引用的对象列进回收范围。
							弱引用，被弱引用关联的对象只能生存到下一次垃圾收集之前，无论内存是否足够，都会被回收。
							虚引用，一个对象是否有虚引用的存在完全不会对其生存时间造成影响，也无非通过虚引用取得对象的实例，虚引用的唯一目的是在这个对象被回收时收到一个系统通知
			
			finalize方法：在可达性分析算法中不可达的对象，会处于缓刑阶段，此时是第一次标记，虚拟机判断此对象有没有必要执行finalize()方法，如果此对象没有
				覆盖finalize方法或者该方法已经被虚拟机调用过了，就是没必要再执行，并进行回收。对于有必要执行finalize方法的对象，会将其放在
				一个队列中由虚拟机创建一个低优先级的线程去执行它，不保证等它执行完毕，如果对象没有在该方法中拯救自己（与引用链上的对象关联），
				进行第二次标记，其还是会被回收。任何对象的finalize方法只会被系统执行一次。不建议用。
				
		2.如何回收？垃圾收集算法
			标记清除算法，首选标记出所有需要回收的对象，标记完成后统一回收。有两个不足，效率不高和空间问题，标记清除后会产生大量不连续的内存碎片，
				  导致以后需要分配大对象时无法找到足够的连续内存，而不得不提前触发另一次垃圾回收动作。
				  
			复制算法，现在主流是用这种方法来回收新生代，将Java堆内存分为一块较大的Eden（伊甸园）和两块较小的Survive（幸存）区，
				  大多数新生对象都被分配在Eden区，第一次GC过后Eden中还存活的对象被移到其中一个Survivor区，再次GC过程中，Eden中还存活的对象会
				  被移到之前已移入对象的Survivor区，一旦该Survivor区域无空间可用时，还存活的对象会从当前Survivor区移到另一个空的Survivor区，
				  而当前Survivor区就会再次置为空状态，经过数次在两个Survivor区域移动后还存活的对象最后会被移动到老年代。
				  
			标记整理算法，复制算法在对象存活率较高时要进行较多复制操作，导致效率变低，而且需要分配担保。所以老年代一般不用这种方法。
				   根据老年代的特点，设计了标记整理算法，标记过程与标记清除算法一样，然后让所有存活的对象都向一端移动，最后直接清理掉端边界以外的内存。

			分代收集算法，根据对象存活周期不同将Java堆划分为新生代和老年代。在新生代中，每次垃圾收集时都有大批对象死去，少量存活，可用复制算法，
			       只需要复制少量对象即可，称为minor GC。
				   而老年代中对象存活率高、没有额外空间进行分配担保，就使用标记清除或者标记整理。称之为major GC(或者full GC)。
		
		不管选择哪种GC算法，stop-the-world都是不可避免的。Stop-the-world意味着从应用中停下来并进入到GC执行过程中去。
		一旦Stop-the-world发生，除了GC所需的线程外，其他线程都将停止工作，中断了的线程直到GC任务结束才继续它们的任务。
		GC调优通常就是为了改善stop-the-world的时间。
		
		3.什么时候回收？
			Minor GC触发条件：
				当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。每次 Minor GC 会清理新生代的内存。
				执行 Minor GC操作时，不会影响到老年代。从老年代到年轻代的引用被当成 GC roots，从老年代到永久代的引用在标记阶段被直接忽略掉。

			Full GC触发条件：
			（1）调用System.gc时，系统建议执行Full GC，但是不必然执行
			（2）老年代空间不足
			（3）方法区（永生代）空间不足
			（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
			（5）由Eden区、Survive区向另一个Survive区复制时，对象大小大于其可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
		
Q：JVM解释编译执行过程
A：// TODO

Q：JVM内存模型
A：JVM在执行Java程序的时候会把它所管理的内存划分为若干个不同的数据区域。有些区域在JVM启动的时候创建，退出的时候销毁。
	     而有些区域依赖于每一个线程，在线程创建时创建，在线程退出时销毁。
	  
	  程序计数器：是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。
						 每个线程都有一个独立的程序计数器，线程私有。是唯一一个不会产生内存溢出的区域。

	  虚拟机栈：也是线程私有的，描述的是Java方法执行时的内存模型，每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、
						动态链接、方法出口等信息。每个方法从调用到完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
						经常把Java内存区分为栈stack和堆heap，其中的栈就是这个。
						
	  本地方法栈：与虚拟机栈非常相似，区别是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈为Native方法服务。有的虚拟机将它们合二为一。
	  
	  Java堆：是最大的一块，被所有线程共享，在物理内存上可以是非连续的。此区域唯一目的就是存放对象实例，
				  原则上所有对象实例和数组都要在堆上分配。堆是垃圾回收器管理的主要区域，从内存回收的角度看，堆还可以细分为新生代和老年代。
	
	  方法区：所有线程共享，用于储存已被虚拟机加载的类信息、常量、静态变量等数据，有些地方称方法区为永生代，
				   将其作为Java堆的一个逻辑部分来管理，这样垃圾回收器就可以像管理Java堆一样管理方法区。但本质上两者并不相等
				   对这一部分的垃圾回收比较少，主要是对常量池的回收和对类型的卸载
		 运行时常量池：方法区的一部分，存放编译器生成的各种字面量和符号引用。具有动态性，运行期也可以将新的常量放入，如String的intern()方法
	   
Q：JVM的类加载机制
A：在Java语言中，类的加载、连接和初始化过程都是在程序运行期间完成的，动态加载动态连接，这样加载时增加了性能开销，但是提供了高度的灵活性
类的生命周期包括加载loading、验证verification、准备preparation、解析resolution、初始化initialization、使用using、卸载unloading，7个阶段
验证、准备、解析统称为连接linking，解析阶段不一定在这个顺序上，可能在初始化之后进行，这是为了支持动态绑定。

	类的加载过程，即加载、验证、准备、解析、初始化这5个阶段
	       加载：1.通过一个类的全限定名来获取定义此类的二进制字节流，
						      没有规定二进制字节流要从哪里获取，可以是zip包如JAR、WAR包；网络；运行时计算生成；其他文件；数据库等
					2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
					3.在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口

	加载阶段可以使用系统提供的类加载器(ClassLoader)来完成，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器
	去控制字节流的获取方式。加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，
	方法区中的数据存储格式有虚拟机实现自行定义，虚拟机并未规定此区域的具体数据结构。然后在java堆中实例化一个java.lang.Class类的对象，
	这个对象作为程序访问方法区中的这些类型数据的外部接口。

Q：类加载器：
      JVM设计者把类加载阶段中的“通过'类全名'来获取定义此类的二进制字节流”这个动作放到Java虚拟机外部去实现，
          以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。

      对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在JVM中的唯一性。每个类加载器都拥有一个独立的类名称空间。
		 要比较两个类是否相等，前提是必须要是同一个类加载器加载的

Q：双亲委派模型：
      从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该类加载器使用C++语言实现，
		属于虚拟机自身的一部分。另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。

	  从Java开发人员的角度来看，大部分Java程序一般会使用到以下三种系统提供的类加载器：
		1)启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库rt.jar到JVM内存中，
				如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。
		2)扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载JAVA_HOME\lib\，该加载器可以被开发者直接使用。
		3)应用程序类加载器（Application ClassLoader）：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，
				开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
			还可以加入自定义的类加载器。
		
		这些类加载器之间有层次关系，称为双亲委派模型。除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器，不是继承关系，而是组合关系。
		
	双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，
		每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求
		（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。		
	
	好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。很好地解决了各个类加载器的基础类统一问题，
		越基础的类由越上层的类加载器进行加载例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，
		因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，
		如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。
		如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。
		
	不足是当基础类想要调用回下层的用户代码时无法委派子类加载器进行类加载。为了解决这个问题JDK引入了ThreadContext线程上下文，
		通过线程上下文的setContextClassLoader方法可以设置线程上下文类加载器。	
		
		