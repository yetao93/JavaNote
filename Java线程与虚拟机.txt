Q：进程和线程的区别是什么？要有深度
A：一个进程是一个独立的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。
线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。

Q：线程的启动方式是start还是run？
A：start是启动线程，run是普通的调用run方法。
	 
Q：创建线程有几种不同的方式？你喜欢哪一种？为什么？
A：有三种方式可以用来创建线程：
		继承Thread类
		实现Runnable接口
		应用程序可以使用Executor框架来创建线程池

		实现Runnable接口比继承Thread类所具有的优势：
			1）：适合多个相同的程序代码的线程去处理同一个资源
			2）：可以避免java中的单继承的限制
			3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
		同时，线程池也是非常高效的，很容易实现和使用。

		main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。
		在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，
		实际上都会启动一个jvm，每一个jvm实现在就是在操作系统中启动了一个进程。
   
Q：线程的五种状态
A：1、新建状态（New）：新创建了一个线程对象。
	2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
	3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
	4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
		（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。
		（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
		（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
	5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

Q：Java等待/通知机制
A：都是Object的方法，必须在同步代码中使用（为了防止在进入wait过程中就调用了notify，导致一直阻塞，等待和通知这两个操作必须互斥）
	是指一个线程A调用了对象O的wait()方法释放了锁并进入等待阻塞状态，另一个线程B调用了对象O的notify()或者notifyAll()方法，
		线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。

	典型用法：分为等待方（消费者）和通知方（生产者）
		等待方遵循以下原则：1.获取对象O的锁
							2.循环判断条件是否满足，如果不满足，调用对象O的wait方法，会释放锁并进入等待阻塞，被通知后仍要检查条件。
							3.条件满足则执行对应的逻辑
		通知方遵循以下原则：1.获得对象O的锁
							2.改变条件，以满足等待方的需求
							3.通知一个或所有等待在对象O上的线程，在同步代码块执行完之后释放锁，被唤醒的线程将竞争对象O的锁
	
	
Q：线程调度
	线程优先级：每一个线程都有优先级，默认继承父线程的优先级，可通过setPriority方法设置。每当线程调度器有机会选择新线程时，
				它首先选择较高优先级的线程，但线程优先级高度依赖操作系统，要看宿主机平台的线程实现机制。
			   
	线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，
				就转为就绪（Runnable）状态。sleep()平台移植性好。
	
	线程让步：Thread.yield() 方法，将当前正在执行的线程对象转为可运行状态，把执行机会让给相同或者更高优先级的线程，很可能没用，
			因为当前线程对象有可能又被线程调度器选中运行。sleep()和yield()的区别
        
		sleep()和yield()的区别:sleep()使当前线程进入阻塞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；
		yield()只是使当前线程重新回到就绪状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。
	
	    为什么sleep和yield都是静态的：因为这两个方法都要在正在执行的线程上被调用，在等待状态的线程上调用这两个方法没有意义。
	
		sleep和wait的区别有：
			1，sleep是Thread类的静态方法，不涉及线程同步的概念；wait是Object的方法，实现等待/通知机制
			2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
			3，wait，notify和notifyAll只能在同步代码中（获得过锁）使用，而sleep可以在任何地方使用
				synchronized(x){
					x.notify()//或者x.wait()
				}
				
	线程加入：join()方法，等待调用者线程终止。在当前线程A中调用另一个线程B的b.join()方法，则线程A转入阻塞状态，
					直到线程B终止之后才从b.join()返回，线程A由阻塞转为就绪状态。另有超时特性，在给定的时间内线程B没有终止，也会从该方法返回。
					这里方法涉及了Java等待/通知机制。
			
	线程中断：interrupt()，只是设置了一个中断状态。
			如果因Object.wait, Thread.join和Thread.sleep三种方法导致了阻塞，则其中断状态将被清除，它还将收到一个InterruptedException异常
　　		要想结束进程最好的办法就是在线程类里面用以个boolean型共享变量来控制run()方法什么时候结束，run()方法一结束，该线程也就结束了。
	
	守护线程：通过调用setDaemon(true)将线程转为守护线程。其唯一用途是为其他线程提供服务，例如计时线程。当只剩下守护线程时，虚拟机就立即退出，守护线程的finally块也不会执行。
			 
	处理未捕获异常的处理器：不被检测的异常会导致线程终止，在线程死亡之前，异常被传递到一个用于未捕获异常的处理器，
						   通过setUncaughtExceptionHandler方法来为线程安装一个处理器，默认为空。
						   
	线程组：如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。线程组是一个可以统一管理的线程集合。
		   ThreadGroup类实现了Thread.UncaughtExceptionHandler接口，按顺序选择下面一个操作：
				1.如果该线程组有父线程组，则调用父线程组的uncaughtException方法
				2.如果Thread.getDefaultExceptionHandler方法返回一个非空的处理器，则调用它
				3.如果Throwable是ThreadDeath的一个实例，什么都不做
				4.线程的名字以及Throwable的栈踪迹被输出到System.err上

   同步：两个或两个以上的线程需要共享同一数据的存取，可能会产生错误。这个情况成为竞争条件。

	main()函数即主函数，是一个前台线程，前台进程是程序中必须执行完成的，而后台线程则是java中所有前台结束后结束，不管有没有完成，后台线程主要用与内存分配等方面。                                                                                           
	前台线程和后台线程的区别和联系：
		1、后台线程不会阻止进程的终止。属于某个进程的所有前台线程都终止后，该进程就会被终止。所有剩余的后台线程都会停止且不会完成。
		2、可以在任何时候将前台线程修改为后台线程，方式是设置Thread.IsBackground 属性。
		3、不管是前台线程还是后台线程，如果线程内出现了异常，都会导致进程的终止。
		4、托管线程池中的线程都是后台线程，使用new Thread方式创建的线程默认都是前台线程。
	说明： 应用程序的主线程以及使用Thread构造的线程都默认为前台线程                       
		使用Thread建立的线程默认情况下是前台线程，在进程中，只要有一个前台线程未退出，进程就不会终止。
		主线程就是一个前台线程。而后台线程不管线程是否结束，只要所有的前台线程都退出（包括正常退出和异常退出）后，进程就会自动终止。
		一般后台线程用于处理时间较短的任务，如在一个Web服务器中可以利用后台线程来处理客户端发过来的请求信息。
		而前台线程一般用于处理需要长时间等待的任务，如在Web服务器中的监听客户端请求的程序，或是定时对某些系统资源进行扫描的程序
		
Q：锁的升级与对比
A：锁有4种状态，级别从低到高依次是无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。
		
		偏向锁：如果同一个线程经常要获得某个锁，为了让它获得锁的代价更低而引入偏向锁。偏向锁使用了一种等到竞争出现才释放锁的机制，
						当其他线程尝试竞争偏向锁时，持有偏向锁的线程才释放锁。
			原理：当一个线程访问同步代码块时并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，
						以后该线程在进入和退出同步代码块时不需要进行CAS操作来加锁和解锁。
			优点：加锁解锁不需要额外的消耗，和执行非同步方法相比差距很小。
			缺点：如果有线程来竞争锁，会带来额外的锁撤销的消耗。
			场景：适用于只有一个线程访问同步块
		
		轻量级锁：// TODO
			优点：竞争的线程不会阻塞
			缺点：如果始终竞争不到锁，线程会自旋消耗CPU
			场景：追求响应时间，同步代码块执行速度非常快
		
		重量级锁：synchronized
			优点：线程竞争不使用自旋，不会消耗CPU
			缺点：线程阻塞，响应时间缓慢
			场景：追求吞吐量，同步代码块执行慢

Q：volatile关键字
A：volatile是轻量级的synchronized，保证从主内存加载到线程工作内存的值是最新的
		用volatile修饰后的变量不允许有不同于主内存区域的变量拷贝。任何线程中改变了它的值必须同步刷新回共享内存，所有其他线程立即获取到了相同的值
		对于volatile修饰的变量，读取时JMM会把该线程对应的本地内存置为无效，然后从主内存读取。但是加载与修改变量的值和写入主内存等操作并不是原子性的，
			所以即使用了volatile修饰变量，仍存在并发的问题。

		关于jvm运行时内存分配：每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，
		首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，
		之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），
		自动把线程变量副本的值回写到对象在堆中变量。
			
Q：synchronized关键字
A：我的理解
	 一、synchronized是重量级锁，可以用于创建代码块、修饰普通方法和静态方法
	 
	 二、创建代码块时需要指一个对象作为互斥体，如果是类的class实例，则锁的是该类的Class对象，相当于修饰所有静态方法。
				如果是一个对象，则锁的是该对象，相当于修饰所有普通方法
	 
	 三、一个类只有一个锁，一个对象也只有一个锁，它们互相不干扰
	 
	 四、当一个线程访问同步代码时，它首先必须得到锁，退出或抛出异常时必须释放锁。另一个线程再想访问该同步代码时会被阻塞，
				但是它可以访问非同步代码，当持有锁的线程释放锁之后会唤醒这个被阻塞的线程，对锁进行新的一轮竞争
				
	 五、本质是对一个对象的监视器monitor进行获取
	 
Q：Lock接口
A：显式地获取和释放锁。
		lock() 方法是平常使用得最多的一个方法，就是用来获取锁，如果锁已被其他线程获取，则进行等待，不可中断。
		tryLock() 尝试非阻塞地获取锁，立即返回true或者false，不可中断
		tryLock(long timeout, TimeUnit unit)，超时的获取锁，会响应中断，即在锁的获取过程中可以中断当前线程，它允许程序打破死锁。
		lockInterruptibly()，它相当于一个超时设为无限的tryLock(long timeout, TimeUnit unit)方法。
		
		
Q：线程池技术
A：ThreadPoolExecutor类是线程池的核心，继承自AbstractExecutorService，其实现了ExecutorService接口，其继承了Executor顶层接口。
		先看其构造方法，有七个参数
			corePoolSize：核心池的大小，在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，
								   当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。
			maximumPoolSize：线程池最大线程数。
			keepAliveTime：表示线程没有任务执行时最多保持多久时间再终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，
			                      keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize
			unit：参数keepAliveTime的时间单位，有7种取值，是在TimeUnit类中的7种静态属性，从天一直到纳秒
			workQueue：阻塞队列，用来存储等待执行的任务。
			                     一般使用LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE
								      和synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。
								 较少使用ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小和PriorityBlockingQueue
			threadFactory：线程工厂，主要用来创建线程
			handler：表示当拒绝处理任务时的策略，有四种取值：
			                    ThreadPoolExecutor.AbortPolicy 丢弃任务并抛出RejectedExecutionException异常、
								ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
								ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
								ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务

		不过不推荐直接使用ThreadPoolExecutor，而是通过Executors的几个静态方法来创建线程池，如果它提供的不满足使用，可以自己创建

		在ThreadPoolExecutor类中有几个非常重要的方法：
			execute() 方法实际上是接口Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，
							这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。
	  　　submit() 方法是在接口ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，
							在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，
							但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，
							会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。
			shutdown() 此时线程池不能够接受新的任务，它会等待所有任务执行完毕
			shutdownNow() 线程池不能接受新的任务，并且会去尝试终止正在执行的任务
			
		重点是execute(Runnable)的执行步骤：
			   如果当前线程数小于核心线程池容量，则开启一个新线程并将该任务作为其第一个任务。
			   如果当前线程数不小于核心线程池容量，就将该任务放进等待队列中。
			   如果队列满了，则开启一个新的非核心线程处理它，此时总线程数不能超过设定的最大值。
			   如果开启非核心线程失败了，按照拒绝策略拒绝该任务。

Q：Callable、Future和FutureTask
A：创建线程的2种方式，一种是直接继承Thread，一种就是实现Runnable接口。这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。
      如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。
	  而自从Java 1.5开始，就提供了Callable和Future接口，通过它们可以在任务执行完毕之后得到任务执行结果。
	  
	  Callable是一个泛型接口，里面call()方法返回的类型就是传递进来的泛型。一般情况下是配合ExecutorService来使用的
	  
	  Future是异步计算的结果，对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果，get()会阻塞直到任务返回结果。
	  FutureTask实现了Runnable和Future接口，它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。

	Callable和Runnable的区别如下：
		I.Callable定义的方法是call，而Runnable定义的方法是run。
		II.Callable的call方法可以有返回值，而Runnable的run方法不能有返回值。
		III.Callable的call方法可抛出异常，而Runnable的run方法不能抛出异常。  
	  
Q：死锁的四个必要条件和如何处理死锁
A：死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
            这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：
				互斥条件：一个资源每次只能被一个进程使用。
				请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
				不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
				循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

	避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。

Q：如何确保线程安全，线程同步的方法，
A：确保线程安全：同步synchronized、使用原子类、实现并发锁、使用volatile关键字、使用不变类和线程安全类。
     同步的方法：用锁！
		
Q：sychronized和lock的区别      
A：Lock接口比同步代码块提供了更具扩展性的锁操作，允许更灵活的结构
		可以使锁更公平
		可以使线程在等待锁的时候响应中断
		可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间
		可以在不同的范围，以不同的顺序获取和释放锁

Q：Java内存模型
A：JMM是共享内存模型，线程之间的通信是隐式的。
		所有变量（实例域、静态域和数组元素但不包括局部变量、方法参数和异常处理器参数，后者是线程私有的）存储在主内存中，每个线程都有
		一个私有的工作内存，工作内存中保存了该线程使用到的变量，是主内存的副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中
		进行，而不能直接操作主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成
		
		本地内存是JMM的一个抽象概念，并不真实存在。
		JMM属于语言级的内存模型。
		
	线程A要和线程B通信的话，有两个步骤，先把线程A的本地内存A中更新过的共享变量刷新到主内存中去，然后线程B到主内存中读取这个共享变量到本地内存B中。
	
	内存间交互操作
	　　关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，
	    Java内存模型定义了以下八种操作来完成：

			lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
			unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
			read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
			load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
			use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
			assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
			store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
			write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。
			　　
		如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，
			就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，
			store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。
			Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

			不允许read和load、store和write操作之一单独出现
			不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
			不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
			一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
			一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
			如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
			如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
			对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

Q：为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume
A：因为该方法本质上是不安全的。停止一个线程将释放它已经锁定的所有监视器。
     如果以前受这些监视器保护的任何对象都处于一种不一致的状态，则损坏的对象将对其他线程可见，这有可能导致任意的行为
	 
Q：GC算法
A：// TODO

Q：JVM解释编译执行过程
A：// TODO

