Q:面向对象编程是什么，有什么优点，和面向过程有什么区别？
A:面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了，数据和对数据的操作是分开的。
面向对象是把某些事物分解成各个对象，将数据和方法封装在一个整体（类）里面，操作时只要调用对象的方法即可，不用关注具体过程。
优点：	1.代码开发模块化，更易维护和修改。2.代码复用。3.增强代码的可靠性和灵活性。4.增加代码的可理解性。
面向对象编程有四大重要的特性： 封装，继承，多态和抽象

Q：JDK、JRE、JVM？什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
A：Java虚拟机（JVm）是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。
虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。
Java虚拟机有自己完善的硬体架构，如 处理器 、 堆栈 、 寄存器 等，还具有相应的 指令 系统。
JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（ 字节码 ），
就可以在多种平台上不加修改地运行。

Java运行时环境(JRE)包含将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。
Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。


Q：什么是Java？
A：Java编程语言是个简单、完全面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的编程语言。

Q:Java标识符由哪些组成？首字符可以是什么？
A：标识符的组成：1.字母 2.数字 3.下划线“_” 4.美元符号$  首字母不能是数字、Java关键字不能做标识符如public,private,package
   所谓的字母是广义的，中文也可以，如“你好”可以作为标识符 
   Java有50个关键字，其中const和goto作为保留字,true、false、null不是严格意思上的Java关键字，main不是关键字

Q:基本数据类型之间的类型转换
A：布尔型boolean与其他基本数据类型不可互相转换。
   字符型char与字节型byte、短整型short之间可以进行强制类型转换，没有强弱之分
   byte < short < int < long < float < double

   byte是字节数据类型，是有符号型的，占1个字节(8个位)；大小范围为-128—127
   char是字符数据类型，是无符号型的，占2字节(Unicode码 ）；大小范围 是0—65535，JAVA用char来表示单个字符。
   如'u','+','中'需要用单引号括起来，将整数赋值，依据ASCII码转化，不能识别负数
   
   char、byte、int对于英文字符，可以依据ASCII码相互转化
   输出时，byte，int会都转换成整数，char转为字符

	Java表达式转型规则由低到高转换：
		1、所有的byte,short,char型的值将被提升为int型；
		2、如果有一个操作数是long型，计算结果是long型；
		3、如果有一个操作数是float型，计算结果是float型；
		4、如果有一个操作数是double型，计算结果是double型；
		5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。
	
	Integer i = 100在编译时会转换成Integer i = Integer.valueOf(100);
	这个方法缓存了-128到127的值，所以如果值相同返回的是同一个对象。

Q:基本数据类型的默认值？
A:若基本数据类型作为类成员变量的时候，即使没有进行初始化。java也会给定默认的初始值。数值为0，布尔型为false
  但是在方法中声明一个变量，可能是任意值，会报错，不会初始化为默认值
   
Q:运算符
A:在取模运算%中，结果的符号与第一个操作数的符号相同， 11 % -5 = 1
  j=j++;运算顺序是先j增加1，然后把j原来的值赋给自己，所以j不变
  <、<=、>、=>只能用来比较基本数据类型（除了boolean），==、!=可以用在基本和引用数据类型上 

Q：==和equals()方法的区别？
A：==是操作符，equals()是Object的方法，其内部就是用的==判断，但是子类可以重写这个方法。
    1、值类型是存储在内存中的堆栈（简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。
　 2、==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。
　 3、equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同，左边不能用于基本数据类型，右边可以自动装箱
　 4、==比较的是2个对象的地址，而equals比较的是2个对象的内容，显然，当equals为true时，==不一定为true。
	总结：==比较的是栈中的内容是否相同，equals()方法比较的是堆中的内容是否相同，比较前先分清堆和栈中的内容是什么！
   ||（条件或）和 &&（条件与）具有 短路规则
   
Q：关于String字符串以及StringBuffer和StringBuilder
A：String是不可变字符串，内部是final修饰的字符数组，其对象一旦产生后就不可以被修改，重新赋值其实是两个对象，需要重新分配内存空间。
   有一个优点：编译器可以让字符串共享。有一个字符串常量池。在编译期确定，存入.class文件
   通过String a = "abc";创建的都是字符串常量，在编译期内确定，只要内容相同，地址也相同。String b = "a" + "bc";也是字符串常量
		而 b+="abc" 或substring等操作不能在编译期确定，得到的结果不是字符串常量，地址不同。
   通过new String();创建的都不是字符串常量，不能在编译期确定.
   
   空串与Null串
   空串""是一个Java对象，有长度（0），有内容（空），判断 str.length()==0 或 str.equals("")
   Null串中放了一个特殊的值Null，表示目前没有任何对象与该变量关联，判断 str == null

   StringBuffer是线程安全的，支持并发操作，其内部必要的方法都加了synchronized。
      跟String的主要区别是其内部的字符数组没有final修饰，所以是可变的。初始化时在内存中预先一定长度的字符数组（默认16）建立一个缓冲区，
      这样效率就比重新分配内存高，所以StringBuffer适用于可变字符串，不管如何操作都是一个对象。
   StringBuilder非线程安全，其他的跟StringBuffer差不多。
	  
Q:关于switch语句
A:对表达式计算，再与每个case子句中的常量值比较，匹配成功则执行该case子句后的语句，直到遇到break为止。
  要注意表达式必须是符合byte、char、short、int类型的表达式，不能使用浮点型或long类型或字符串（新版java支持字符串）

Q:Java支持哪三种跳转语句？
A:break、continue 和 return 
  break有三种作用 1.被用来终止switch 2.终止for、while循环 3.跳出带标号的语句块
  continue语句只结束本次循环，而break是结束整个循环语句的执行
  return语句的作用是终止当前方法的执行，返回到这个方法的调用者

Q:类的加载过程与对象的初始化
A:当程序执行时，需要生成某个类的对象，Java执行引擎会先检查是否加载了这个类，如果没有加载，则先执行类的加载再生成对象，
  在类的加载过程中，类的static成员变量会被初始化，如果类中有static语句块，则会执行static语句块。
	初始化static成员变量和执行static语句块的顺序同代码中的顺序一致。记住，在Java中，类是按需加载，只有当需要用到这个类的时候，
	才会加载这个类，并且只会加载一次。
  在生成对象的过程中，会先初始化对象的成员变量，然后再执行块，再执行构造器。
  父类加载-->子类加载-->父类初始化-->子类初始化
  类实例销毁时候，首先销毁子类部分，再销毁父类部分

Q：关于构造方法
A：修饰符可以有访问权限的修饰词（4种），不能有其他如abstract、final、native、static或synchronized
   方法名即类名，可以有任意个参数，没有返回类型也没有void
   默认有一个无参构造方法，但如果已经有了定义的构造方法，系统不会创建这个默认无参构造方法

Q：构造方法的继承性
A：构造方法是从顶向下进行调用的，子类的构造方法中必须要通过super关键字在第一行调用父类的构造方法，
	 如果调用的是父类无参构造方法，可省略super()，系统会自动加上
	 如果调用父类有参构造方法，必须显式调用super(...)，确保子类在初始化前父类会被实例化
     父类的构造器调用以及初始化过程一定在子类的前面。	
   
Q：关于main方法
A：修饰符public 因为main方法是JVM自动调用的，需要让JVM可见
   static：由于main是所有程序的入口，被调用时没有任何对象创建，要想不通过对象调用某一方法，只有将该方法定义为static方法
   void：JVM对于Java程序来说已经是系统的最底层，由它调用的方法的返回值无处可去
   String args[]：能够接收命令行传入的参数

Q：方法参数的传递
A：★java中的变量有两种类型：引用类型(对象)和基本数据类型。当他们被作为参数传递给方法时，他们都是传值的副本或者引用地址的副本！

Q: static关键字
A：类变量和类方法的调用，直接 类名.类变量  类名.类方法（【参数列表】）
   两条重要原则：1.类方法不能访问所属类的非静态变量和方法，只能访问方法体内的局部变量、参数和静态变量
	             2.类方法中不能出现this和super关键字
   static修饰的变量和方法能独立于任何对象，因此某一个对象修改了类变量的值，会导致所有对象中的类变量一起发生改变，
   因为所有的对象中的类变量仅仅存放的是一个引用值，该引用值都是指向类变量真正存放的静态存储区的内存地址
   如果要通过计算来初始化static变量，可以声明一个static语句块，仅在该类第一次被加载时执行
 
Q：“static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？
A：“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

Q：是否可以在static环境中访问非static变量？
static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

Q：final关键字
A：final关键字可以用来修饰变量、方法和类。
   当final修饰基本数据类型时，该变量就成了常量，值无法改变
   当final修饰引用数据类型时，该变量的值不能改变，即储存的地址不变，不能再去指向别的对象，但对象内的成员可以改变
	用final修饰的类称为最终类，该类不能被继承，其中的方法自动成为final方法，不包括属性
	用final修饰的方法不能被子类覆盖
	用final修饰方法的参数，表示该方法不期望该参数传进来后有任何改变

Q：封装性
A：可见度：同一个类中、同一个包中、不同包的子类、不同包的非子类
   权  限:private、default、protected、public
   类能使用的访问修饰符只有default和public
   类成员能使用四种，其中default不能写出来
   方法中的变量不能有访问修饰符

Q:继承性
A:子类继承父类的成员变量，当子类继承了某个类之后，便可以使用父类中的成员变量，但是并不是完全继承父类的所有成员变量
　1）能够继承父类的public和protected成员变量；不能够继承父类的private成员变量；
　2）对于父类的default成员变量，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
　3）对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，
		即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。
		
　子类继承父类的方法，同样地，子类也并不是完全继承父类的所有方法。
　1）能够继承父类的public和protected成员方法；不能够继承父类的private成员方法；
　2）对于父类的default成员方法，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
　3）对于子类可以继承的父类成员方法，如果在子类中出现了同名称的成员方法，则称为覆盖，
		即子类的成员方法会覆盖掉父类的同名成员方法。如果要在子类中访问父类中同名成员方法，需要使用super关键字来进行引用。
	4）对于protected的成员或方法，要分子类和父类是否在同一个包中。与父类不在同一个包中的子类，
		只能访问自身从基类继承而来的受保护成员，而不能访问基类实例本身的受保护成员。super是个例外。
		典型的例子，定义Father、Son类，在各自的类里面，都可以访问Object的clone方法，但是在类外面，均不能访问。
			在Son中也不能通过Father访问其clone方法，因为Father如果没有重写该方法，那么便是Object的
	
　注意：隐藏和覆盖是不同的。隐藏是针对成员变量和静态方法的，而覆盖是针对普通方法的。
  覆盖只针对非静态方法（终态方法不能被继承，所以就不存在覆盖一说了），而隐藏是针对成员变量和静态方法的。
  这2者之间的区别是：覆盖受RTTI（Runtime type  identification）约束的，而隐藏却不受该约束。
  也就是说只有覆盖方法才会进行动态绑定，而隐藏是不会发生动态绑定的。除了static方法和final方法，其他所有的方法都是动态绑定

Q：封装，多态，继承，抽象的解释？
A：封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。好处:1.通过隐藏对象的属性来保护对象内部的状态。2.提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。3.禁止对象之间的不良交互提高模块化。
多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。
表现形式主要有两种：方法重载Overloading，又称静态多态性，同一类中允许多个同名方法，但要求参数个数不同或参数类型不同或参数顺序不同。
方法覆盖Overriding，又称动态多态性，子类对父类方法重新定义，但方法名、返回值和参数形态完全一样。
继承给对象提供了从父类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。
抽象是把想法从具体的实例中分离出来的步骤，这种抽象技术的主要目的是把类的行为和实现细节分离开。
抽象和封装的不同点。抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。

方法的覆盖（override）两同两小一大原则：
方法名相同，参数类型相同
子类返回类型小于等于父类方法返回类型，
子类抛出异常小于等于父类方法抛出异常，
子类访问权限大于等于父类方法访问权限。
  
Q：向上转型，强制类型转换
A：Father father = new Son(); 
			father是Father类的对象，变量是Father的，但方法是Son类的。在内存中本质还是Son类型的，
			只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！
      Son son = (Son)father;
			这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，
			将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。
			
	当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。
		Father father = new  Father();
		Son son = (Son) father;
		所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。		
		在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。
		
   子类可以向父类进行类型转型，使父类的的对象能引用子类的对象，父类的对象是通过实例化一个子类的对象而来的。
   向上转型后的对象是父类对象，没法调用子类的成员方法和成员变量，但如果存在同名的方法，也就是方法覆盖，父类的方法会被子类覆盖
   动态方法调度机制仅对方法有效，如果存在同名的变量，调用的还是父类的变量，可以通过调用被子类覆盖的方法访问子类的变量

   null可以被强制类型转换成任意类型，可以用来执行静态方法
   
Q：多态性，方法重载Overloading，方法覆盖Overriding
A：方法重载Overloading，又称静态多态性，方法名以及参数列表称为方法的签名，不同的方法，签名必须不同，方法重载要求方法名相同，
	那么参数列表不能相同，返回类型不是方法签名的一部分。
   方法覆盖Overriding，又称动态多态性，调用方式为动态绑定，子类对父类方法重新定义，但方法名、返回类型和参数列表要求一样。
   允许子类将覆盖方法的返回类型定义为原返回类型的子类型。子类方法不能缩小访问权限！	
   父类静态方法不能被覆盖！私有方法不能被覆盖！final修饰的方法不能被覆盖！这三种是静态绑定

   
Q：抽象类
A：抽象类是专门设计用来让子类继承的类，提供一个类的部分实现，其内部可以有成员变量、构造方法、具体方法和抽象方法。
   抽象方法以分号结束！abstract 返回类型 方法名（参数列表）;
   抽象类不会有实例，在JDK1.8可以有main方法，可以运行，可以有构造方法
   对于类，不能同时用final和abstract说明，
   1、抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。
   原因如下：抽象方法没有方法体，是用来被继承的，所以不能用private修饰；static修饰的方法可以通过类名来访问该方法（即该方法的方法体），
   抽象方法用static修饰没有意义；使用synchronized关键字是为该方法加一个锁。。而如果该关键字修饰的方法是static方法。
   则使用的锁就是class对象的锁。如果是修饰类方法。则用this变量锁。但是抽象类不能实例化对象，因为该方法不是在该抽象类中实现的。
   是在其子类实现的。所以。锁应该归其子类所有。所以。抽象方 法也就不能用synchronized关键字修饰了；
   native，这个东西本身就和abstract冲突，他们都是方法的声明，只是一个吧方法实现移交给子类，另一个是移交给本地操作系统。
   如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢？ 

   
Q：接口
A：接口不是类，而是对类的一组需求描述，由常量和抽象方法组成，
   [public] interface 接口名 [extends...]{
	数据类型 变量名 = 常量值；
	返回类型 方法名（参数列表）;
   }
   接口具有继承性，可以继承多个父接口，用逗号隔开，interface C extends A,B{...}
   默认接口中所有成员变量的修饰都是加上public、static、final
   默认接口中所有成员方法都是public、abstract，
   only public, abstract, default, static and strictfp are permitted，如果改成default或static就要添加方法体，不是抽象方法了
   only one of abstract, default, or static permitted
   接口本身具有抽象属性，加不加abstract都可以，访问控制权限只有public和default	   
   同一个Java源文件只能有一个public修饰的类或接口
   接口不含构造方法，不能直接通过接口生成接口
   实际测试jdk8：接口可以有main方法，可以运行，不能用new实例化
		 可以有静态方法，要有方法体，此时已不是抽象方法，可以在main里面直接调用运行
		 可以有default修饰的方法，必须有方法体，此时已不是抽象方法
   当一个类实现了一个接口，就必须实现其中所有的方法，就是方法覆盖，由于方法覆盖不能缩小父类方法的访问权限，
	而接口方法默认public，实现的方法也必须是public
   接口回调，interface A{} class B implements A{}  A a = new B();
	a被定义成接口A类型，被一个B实例赋值，只有接口定义声明的方法，
	那B的属性以及其他方法呢，如果它实现接口声明的方法中有其他属性和方法呢，实践证明都是可以在接口声明的方法里用

Q：接口和抽象类的区别是什么？
A：Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
类可以实现很多个接口，但是只能继承一个抽象类
类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
抽象类可以在不提供接口方法实现的情况下实现接口。
Java接口中声明的变量默认都是static final的，不过接口一般不定义变量。抽象类可以包含非final的变量。
Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。

	
Q：内部类
A：如果类B被定义在类A内，那么类B就是一个内部类，它为类A所知，不被类A的外界所知，类B可以访问类A的成员，包括private成员。
	内部类的类名只用于定义它的类或语句块中，在外部引用必须给出带外部类的完整名称。
	内部类的名字不允许与外部类的名字相同。
	内部类可以是抽象类或接口，若是接口，则可以由其他内部类实现。
    按照内部类是否有显示的类名来划分为  实名内部类和匿名内部类
	  实名内部类可以有四种访问控制方式，可以有static称为静态实名内部类，创建格式为：new 外部类名.实名内部类名（参数列表）
	      没有static的称为不具有静态属性的实名内部类，它的成员变量若有静态属性，则必须有final属性，但成员方法不能有静态属性，
		  创建格式：外部类实例对象.new 实名内部类名（参数列表）
	      访问静态属性的成员：外部类名.实名内部类名.静态成员
              访问不具有静态属性的成员：实名内部类实例对象.成员
      	  匿名内部类，不具有类名，且类不具有抽象和静态属性，也不能排生出子类，
		  定义格式：new 父类名（父类型的构造方法的参数列表）{...}
	      优点1.进一步实现多重继承，可以使用接口实现多重继承，但必须实现接口里所有方法，而通过内部类就没这个问题
		  2.能更好地解决接口和父类中方法的同名冲突，即通过一个内部类来实现接口，本类继承父类
		  3.隐藏程序实现的细节
		  4.能够无条件访问外部类的成员


Q：反射
A：主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。
	在java中，通过反射，能够在"运行态"动态获得任意一个类的所有属性和方法，动态地调用对象的方法。

	在程序运行期间，系统始终为所有的对象维护一个被称为运行时的类型标识，这个信息跟踪每个对象所属的类。
	可以通过专门的Java类访问这些信息，保存这些信息的类被称为Class，有三种方法获取Class
	1.对象的getClass()方法会返回一个Class类型的实例。
	2.类.class返回一个Class类型的实例。
	3.知道类的包名类名，可以通过Class的静态方法forName(String name)得到类名对应的Class对象，并且动态加载了这个类。
	

	可以用Class的newInstance()方法快速创建一个类的实例，调用的是无参构造方法，如果没有无参构造方法，则报错。
	getFields、getMethods、getConstructors方法分别返回类提供的public属性、方法和构造器数组，包括超类的公有成员
	要是其中加了Declare，如getDeclareFields方法，将返回类中声明的全部属性、方法和构造器，但不包括超类的成员

	检查类的结构：有三个类Field、Method、Constructor分别描述类的属性、方法和构造方法
	Modifier类可以分析修饰符，getModifiers()方法获得调用它的类或属性或方法的修饰符,用它的toString(int mod)方法将修饰符打印输出

	运行时查看属性的实际内容：class.getDeclareField(属性名).get(对象名)，不能看私有属性，要查看得加上Field.setAccessible(true)
	可以获得就可以设置，Field.set(对象名，值)

	调用方法：先得到指定方法名getMethod(String name,Class...parameterTypes)，调用invoke(Object obj,Object...args)
	method.invoke(对象名，参数s)，若是静态方法，则对象名为null

		
Q：集合类（有序的意思是根据添加的顺序存放）和数组
A：Collection接口是集合接口树的根。java提供了一个操作Set、List、Map等集合的工具类：Collections，
	该工具类里提供了大量方法对集合进行排序、查询、修改等操作，还提供了将集合对象设置为不可变、对集合对象实现同步控制等方法。

	Set接口无序不重复：
		HashSet是Set接口的典型实现，是最常用的Set实现类，当向其中存一个元素的时候，HashSet会调用该对象的hashCode()方法
		得到该对象的hashCode值（伪地址），然后根据hashCode值向相应的内存中存放元素。如果两个元素的equals相等而它们的hashCode值
		不同，则HashSet会将它们存放在不同的位置。如果它们的hashCode值相同，但是equals返回值不同，HashSet会在这个位置用链式结构
		保存多个元素（相当于Hash用链表防止冲突），这样会导致性能下降，所以一般在重写equals方法的时候，也应该重写hashCode方法。
		如果hashcode值相同，equals也返回true，则不能重复添加，只显示一个。
		
		LinkedHashSet原理实现和HashSet基本相同，不同的是它除了根据对象的hashCode值决定存放位置，
		还使用了链表来维护元素的次序，所以是有序存放的。
		
		TreeSet是SortedSet接口的实现类,它的数据结构采用的是红黑树，所以它可以对元素进行排序，但元素是不重复的。
		而且提供了comparator方法可以定制排序，当不使用comParator方法时，它是根据元素的compareTo方法来判断元素大小的，
		所以在使用TreeSet的时候，如果要重写equals方法，应该注意其compareTo方法也要重写；
		
		HashSet是最常用的，但是其具有不重复无序的特点，
		LinkedHashSet由于采用链式维护，所以其是有序的，但性能降低了；
		TreeSet由于需要额外的红黑树来维护集合元素的次序，所以其性能不好，但是如果集合元素需要排序可以考虑用TreeSet;
	
	List接口有序可重复：
		ArrayList与Vector作为List类的两个典型实现，基本功能是一样，只不是Vector出现的早点，ArrayList是后来出现在的，
		所以ArrayList的方法名可以短一些，两者实现的原理都是封装了一个动态的、允许再分配的Object[]数组，
		另外ArrayList是线程不安全的，Vector是线程安全的，效率很低，尽量少用。

		LinkedList也是List的实现类，它是一个基于链表实现的List类，对于迭代访问，插入、删除的速度非常快，
		但是如果如果根据索引拿取元素，它就不那么快了，这时应该用ArrayList；另外LinkedList还实现了Deque接口，
		因此它可以被当成双端队列来使用，自然也可以被当成“栈”来使用，因此现在的程序中需要使用“栈”这种数据结构时，
		推荐使用ArrayDeueue或LinkedList，而不是Stack；
		
		ArrayList是基于数组实现的，所以查询快，增删慢；LinkedList是基于链表实现的，所以查找慢，增删快。
		
		一些操作：添加add() 移除remove(index) 得到get(index) 修改set(index,"") 元素数size() 打乱顺序Collections.shuffle(list)
		
	Map接口键值对形式：
		Map是用来保存具有映射关系的数据，是一个无序不可重复的集合，相当于“关联数组”；Set和Map的关系十分密切，
		java源码就是先实现了HashMap、TreeMap等集合，然后通过包装一个所有的value都为null的Map集合实现了Set集合类，
		所以呢在说Map的时候key值几乎和我们说的set一模一样，所以相似的我就不多提了。详见Java集合.md
	
	集合中线程安全的类有：Vector，Hashtable , Stack，Enumeration，除此之外均是非线程安全的类与接口
	
Q：Java集合类框架的基本接口有哪些？
Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：
Collection：代表一组对象，每一个对象都是它的子元素。
Set：不包含重复元素的Collection。
List：有顺序的collection，并且可以包含重复元素。
Map：可以把键(key)映射到值(value)的对象，键不能重复。


Q：什么是迭代器(Iterator)？
Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的
迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。


Q：Iterator和ListIterator的区别是什么？
下面列出了他们的区别：
Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。


Q：HashMap和Hashtable有什么区别？
HashMap和Hashtable都实现了Map接口，几乎可以等价。但是，他们有以下不同点：
主要的区别有：线程安全性，以及速度。
Hashtable是线程安全的，它里面的方法都用了synchronized修饰，速度慢，而HashMap不是
另一个区别是HashMap的迭代器是fail-fast迭代器，而Hashtable的enumerator（列举）迭代器不是fail-fast的。
HashMap允许键和值是null，而Hashtable不允许键或者值是null。
如果要将HashMap变成线程安全的，推荐使用ConcurrentHashMap，
也可以使用Collections.synchronizedMap(Map)方法，它是给每个操作加synchronized


Q：数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？
下面列出了Array和ArrayList的不同点：
Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
Array大小是固定的，ArrayList的大小是动态变化的。
ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。


Q：ArrayList和LinkedList有什么区别？
ArrayList和LinkedList都实现了List接口，他们有以下的不同点：
ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。
相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。
LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。

ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，
如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，
然后，把之前的数据拷贝到新建的数组。

对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
ArrayList是数组，所以，直接定位到相应位置取元素，LinkedLIst是链表，所以需要从前往后遍历。

ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。
正确，因为ArrayList空间的增长率为1.5倍，所以，最后很可能留下一部分空间是没有用到的，因此，会造成浪费的情况。对于LInkedList的话，
由于每个节点都需要额外的指针

Q：HashSet和TreeSet有什么区别？
HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。
另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。


Q：如何权衡是使用无序的数组还是有序的数组？
有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。


Q：Java集合类框架的最佳实践有哪些？
根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。
有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。
为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。
使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。
编程的时候接口优于实现。
底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。

Q：关于泛型
A：1.虚拟机中没有泛型，只有普通类和普通方法
	 2.所有泛型类的类型参数在编译时都会被擦除
	 3.虽然有泛型的类型擦除机制，但也能在运行时动态获取List<T>中T的实际类型，通过反射

Q：关于输入输出流I/O
A：流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，
     根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 

	  抽象类InputStream和OutputStream构成了输入/输出类层次结构的基础。
	  （字节流不便处理Unicode编码的信息，因为其每个字符用了多个字节来表示。所以有单独的类层次结构处理它，都是基于两字节的。）
	  
	  抽象方法read()和write()是最基础的，读写一个字节，在执行时都将阻塞，直至字节确实被读入或者写出。
	  
	  完成对流的读写时应该调用close()来关闭，释放系统资源。关闭输出流的同时还会冲刷其缓冲区，也可用flush()来手动冲刷。
   
	字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 
	字节流Byte和字符流Char的区别：
		读写单位不同：字节流以字节（1Byte = 8bit）为单位，字符流以字符为单位，一次可能读多个字节，根据指定的编码表映射字符。
		处理对象不同：字节流能处理所有类型的数据（如图片、avi、MP3等），而字符流只能处理字符类型的数据。
	结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。
  
	读取时的字节数组或字符数组的长度如何确定？
  
	缓冲区的作用：
	用了BufferedInputStream后你每次读取都是从缓冲区里拷贝数据，缓冲区没东西了就调IO从数据源读到缓冲区，然后你再从缓冲区读。
	为什么会这样呢，因为你自己建立的数组大小和缓冲区大小一样，根本就没起到缓冲作用。
	当你程序的数组小于缓冲区的时候才会起到缓冲作用。
	比如是byte[] b=new byte[2048];，你要读的数据是1M，那么你要调512次IO，假设一次1s，就512s，
	但如果用BufferedInputStream，你每从缓冲区读取4（8192/2048=4）次才调用一次IO（假设访问内存一次0.1s），总共要128次，就128s，
	加上总的从缓冲区拷贝数据的时间（512*0.1=51.2s），128+51.2=179.2。这里用0.1s和1s来体现IO很耗时
  
    使用字节流读写：InputStream、OutputStream   （都是抽象类）
   
    使用带缓冲的字节流读写：字节流+BufferedInputStream、字节流+BufferedOutputStream

    使用字符流读写：字节流+InputStreamReader、字节流+OutputStreamWriter  
   
    使用带缓冲的字符流读写：字符流+BufferedReader、字符流+BufferedWriter

	基于磁盘操作的I/O：File
		文件读取类FileReader extends InputStreamReader
		文件输出类FileWriter extends OutputStreamWriter   
			已经是字符流了，只能处理纯文本数据，但并没有实现父类中带字符集参数的构造函数，所以仅能按系统默认的字符集编解码。所以不推荐，还是用父类好。
		    PrintWriter和其他Writer的区别：其他Writer没有相关的格式化的方法，而PrintWriter可以在写入同时对写入的数据进行格式化。
		
	基于网络操作的I/O：socket

Q：NIO
A：// TODO	
	
	
Q：对象序列化
A：可以将任何对象写出到流中，也可以从流中读回。可以将对象保存到磁盘中，或者通过网络传输。
     每个对象都有一个序列号，用以代替原生的内存地址。


Q：JDBC连接数据库的步骤：
	加载驱动程序 Class.forName("com.ibm.db2.jcc.DB2Driver");
	与数据库建立连接 Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/jsp_db","admin","admin");
	执行查询，发送SQL语句 Statement stmt = con.creatStatement();
	获取结果集 ResultSet rs = stmt.executeQuery("SELECT * FROM user");
		   while(rs.next()){
			String s = rs.getString("name");
		   }
	关闭连接，清理环境
	
Q：PreparedStatement和Statement的区别
	1>PreparedStatement 接口继承 Statement
		PreparedStatement用于处理动态SQL语句，在执行前会有一个预编译过程，这个过程是有时间开销的，虽然相对数据库的操作，
		该时间开销可以忽略不计，但是PreparedStatement的预编译结果会被缓存，下次执行相同的预编译语句时，就不需要编译，
		只要将参数直接传入编译过的语句执行代码中就会得到执行，所以，对于批量处理可以大大提高效率。
	2>Statement每次都会执行SQL语句，相关数据库都要执行SQL语句的编译。
	3>作为开发者，应该尽可能以PreparedStatement代替Statement，提高了性能，提高安全性，防止sql注入
	
	Statement sta=con.createStatement();   ResultSet rst=sta.executeQuery(“select * from book where id = 1”);
	
	PreparedStatement pst=con.prepareStatement(“select * from book where id = ?”);
	pst.setParameter('1');
	ResultSet rst=pst.executeQuery();


Q:关于异常Exception
异常对象都是派生于Throwable类的一个实例。在下一层分成两个分支：Error和Exception。Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误，很少出现，一般不需要程序员处理。
需要关注的是Exception层次结构，又分解为两个分支：由程序错误导致的异常RuntimeException（错误的类型转换、数组越界、访问空指针等）
和程序没有问题但由于I/O错误这类问题导致的其他异常（在文件尾部后面读取数据、打开不存在的文件、根据给定的字符串查找不存在的Class对象）。
出现RuntimeException（不要关注这个名字）就一定是程序员的问题，应通过检测避免发生这类异常。
将派生于Error类或RuntimeException类的所有异常称为未检查异常，其他的称为已检查异常。编译器要求为所有已检查异常提供异常处理器。
也就是说除了不可控制的Error，程序员要避免发生RuntimeException的未检查异常，为其他的已检查异常提供异常处理器。
方法应该在其首部声明所有可能抛出的已检查异常（或者捕获）。例如public FileInputStream(String name) throws FileNotFoundException。
声明抛出的异常如果是某个特定类的实例时，可能抛出一个这个类的异常或者这个类的任意一个子类的异常。例如声明抛出IOException异常，既可能是IOException异常，
也可能是其子类异常例如FileNotFoundException。
抛出异常异常类：1.找到一个合适的异常类。2.创建这个类的一个对象。3.将对象抛出throw。一旦抛出，这个方法就不可能返回到调用者。
使用try...catch捕获异常并进行处理。通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常使用throws抛出，传递给它的调用者。

Q：throw和throws有什么区别？
throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。

Q：异常处理的时候，finally代码块的重要性是什么？
无论是否抛出异常，finally代码块总是会被执行。就算是没有catch语句同时又抛出异常的情况下，finally代码块仍然会被执行。最后要说的是，finally代码块主要用来释放资源，比如：I/O缓冲区，数据库连接。

Q：try...catch...finally与return
1、不管有没有有出现异常，finally块中代码都会执行；
2、当try和catch中有return时，finally仍然会执行；
3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存在临时变量，不管finally中的代码怎么样，
	返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
4、finally中最好不要包含return，否则程序会提前退出，会把try或者catch中的return覆盖掉。

Q：异常处理完成以后，Exception对象会发生什么变化？
Exception对象会在下一个垃圾回收过程中被回收掉。

Q：finally代码块和finalize()方法有什么区别？
无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。

Q：中间件
A：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/服务器的操作系统之上，
管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件相连接的系统，即使它们具有不同的接口，
但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。 
  （简单来说，中间件并不能提高内核的效率，一般只是负责网络信息的分发处理）

Q：java1.8的新特性
A：// TODO

Q：java数据结构
A：// TODO

Q：判断单链表有没有环
A：// TODO

Q：排序算法，重点问了快排，快排的优化
A：// TODO

Q：操作系统同步方式、通信方式
A：// TODO

Q：计算机网络三次握手四次分手以及wait_time三种差别
A：SYN(synchronous同步)、ACK(acknowledgement 确认)、FIN(finish结束)
     TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
		第一次：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。
		第二次：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。
		第三次：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。

	 连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作
		（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 
		（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 客户端收到后关闭写通道。
		（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 
		（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 
	
	 发起TCP连接关闭的一方称为client，被动关闭的一方称为server。	
	 CLOSE_WAIT
          发生在被动关闭一方。被动关闭的server收到FIN后，但未发出ACK的TCP状态是CLOSE_WAIT。
		  出现这种状况一般都是由于server端代码的问题，如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。
	 TIME_WAIT
	       在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，
		   它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。在这个状态下保持2倍的MSL，
		   MSL指一个片段在网络中最大的存活时间，2倍就是一个发送和一个回复所需的最大时间。如果这段时间内都没有再收到FIN，那就关闭。
		   为什么不直接进入CLOESD状态，原因有二：
				一、保证TCP协议的全双工连接能够可靠关闭
				二、保证这次连接的重复数据段从网络中消失

		为什么TCP建立连接要进行3次握手,而断开连接要进行4次？
			因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。
			但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。
			只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步挥手。

Q：Http post和get差别
A：GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&连接。URL的编码格式采用的是ASCII编码，而不是uniclde，
		即是说所有的非ASCII字符都要编码之后再传输。
	 POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中
	 因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。POST的安全性比GET的高。
	 
	 在HTTP规范中，没有对URL的长度和传输的数据大小进行限制。但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的长度有限制。
	     因此，在使用GET请求时，传输数据会受到URL长度的限制。
	 对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制

Q：http状态码
A：消息（1字头）、成功（2字头）、重定向（3字头）、请求错误（4字头）、服务器错误（5、6字头）

Q：TCP最大连接数，TCP和UDP的区别
A：// TODO

Q：进制转换算法
A：一般都是由十进制转换成其他进制。转换成二进制就不断做除以2取余操作，八进制除以8取余，十六进制除以16取余。