Q:Java标识符由哪些组成？首字符可以是什么？
A：标识符的组成：1.字母 2.数字 3.下划线“_” 4.美元符号$  首字母不能是数字、Java关键字不能做标识符如public,private,package
   所谓的字母是广义的，中文也可以，如“你好”可以作为标识符 
   Java有50个关键字，其中const和goto作为保留字,true、false、null不是严格意思上的Java关键字，main不是关键字

Q:基本数据类型之间的类型转换
A：布尔型boolean与其他基本数据类型不可互相转换。
   字符型char与字节型byte、短整型short之间可以进行强制类型转换，没有强弱之分
   byte < short < int < long < float < double

   byte是字节数据类型，是有符号型的，占1个字节(8个位)；大小范围为-128—127
   char是字符数据类型，是无符号型的，占2字节(Unicode码 ）；大小范围 是0—65535，JAVA用char来表示单个字符。
   如'u','+','中'需要用单引号括起来，将整数赋值，依据ASCII码转化，不能识别负数
   
   char、byte、int对于英文字符，可以依据ASCII码相互转化
   输出时，byte，int会都转换成整数，char转为字符
   
Q:基本数据类型的默认值？
A:若基本数据类型作为类成员变量的时候，即使没有进行初始化。java也会给定默认的初始值。数值为0，布尔型为false
  但是在方法中声明一个变量，可能是任意值，会报错，不会初始化为默认值
   
Q:运算符
A:在取模运算%中，结果的符号与第一个操作数的符号相同， 11 % -5 = 1
  j=j++;运算顺序是先j增加1，然后把j原来的值赋给自己，所以j不变
  <、<=、>、=>只能用来比较基本数据类型（除了boolean），==、!=可以用在基本和引用数据类型上 

Q：==和equals()方法的区别？
A：1、值类型是存储在内存中的堆栈（简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。
　 2、==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。
　 3、equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同，左边不能用于基本数据类型，右边可以自动装箱
　 4、==比较的是2个对象的地址，而equals比较的是2个对象的内容，显然，当equals为true时，==不一定为true。
	总结：==比较的是栈中的内容是否相同，equals()方法比较的是堆中的内容是否相同，比较前先分清堆和栈中的内容是什么！
   ||（条件或）和 &&（条件与）具有 短路规则
   
Q：关于String字符串
A：String是不可变字符串，有一个优点：编译器可以让字符串共享。有一个字符串常量池。在编译期确定，存入.class文件
   通过String a = "abc";创建的都是字符串常量，在编译期内确定，只要内容相同，地址也相同。String b = "a" + "bc";也是字符串常量
		而 b+="abc" 或substring等操作不能在编译期确定，得到的结果不是字符串常量，地址不同。
   通过new String();创建的都不是字符串常量，不能在编译期确定.
   
   空串与Null串
   空串""是一个Java对象，有长度（0），有内容（空），判断 str.length()==0 或 str.equals("")
   Null串中放了一个特殊的值Null，表示目前没有任何对象与该变量关联，判断 str == null

Q:关于switch语句
A:对表达式计算，再与每个case子句中的常量值比较，匹配成功则执行该case子句后的语句，直到遇到break为止。
  要注意表达式必须是符合byte、char、short、int类型的表达式，不能使用浮点型或long类型或字符串（新版java支持字符串）

Q:Java支持哪三种跳转语句？
A:break、continue 和 return 
  break有三种作用 1.被用来终止switch 2.终止for、while循环 3.跳出带标号的语句块
  continue语句只结束本次循环，而break是结束整个循环语句的执行
  return语句的作用是终止当前方法的执行，返回到这个方法的调用者

Q:类的加载与对象的初始化
A:当程序执行时，需要生成某个类的对象，Java执行引擎会先检查是否加载了这个类，如果没有加载，则先执行类的加载再生成对象，
  在类的加载过程中，类的static成员变量会被初始化，如果类中有static语句块，则会执行static语句块。
	初始化static成员变量和执行static语句块的顺序同代码中的顺序一致。记住，在Java中，类是按需加载，只有当需要用到这个类的时候，
	才会加载这个类，并且只会加载一次。
  在生成对象的过程中，会先初始化对象的成员变量，然后再执行块，再执行构造器。
  父类加载-->子类加载-->父类初始化-->子类初始化

Q：关于构造方法
A：修饰符可以有访问权限的修饰词（4种），不能有其他如abstract、final、native、static或synchronized
   方法名即类名，可以有任意个参数，没有返回类型也没有void
   默认有一个无参构造方法，但如果已经有了定义的构造方法，系统不会创建这个默认无参构造方法

Q：构造方法的继承性
A：构造方法是从顶向下进行调用的，子类的构造方法中必须要通过super关键字在第一行调用父类的构造方法，
	 如果调用的是父类无参构造方法，可省略super()，系统会自动加上
	 如果调用父类有参构造方法，必须显式调用super(...)，确保子类在初始化前父类会被实例化
     父类的构造器调用以及初始化过程一定在子类的前面。	
   
Q：关于main方法
A：修饰符public 因为main方法是JVM自动调用的，需要让JVM可见
   static：由于main是所有程序的入口，被调用时没有任何对象创建，要想不通过对象调用某一方法，只有将该方法定义为static方法
   void：JVM对于Java程序来说已经是系统的最底层，由它调用的方法的返回值无处可去
   String args[]：能够接收命令行传入的参数

Q：方法参数的传递
A：★java中的变量有两种类型：引用类型(对象)和基本数据类型。当他们被作为参数传递给方法时，他们都是传值的副本或者引用地址的副本！

Q: static关键字
A：类变量和类方法的调用，直接 类名.类变量  类名.类方法（【参数列表】）
   两条重要原则：1.类方法不能访问所属类的非静态变量和方法，只能访问方法体内的局部变量、参数和静态变量
	             2.类方法中不能出现this和super关键字
   static修饰的变量和方法能独立于任何对象，因此某一个对象修改了类变量的值，会导致所有对象中的类变量一起发生改变，
   因为所有的对象中的类变量仅仅存放的是一个引用值，该引用值都是指向类变量真正存放的静态存储区的内存地址
   如果要通过计算来初始化static变量，可以声明一个static语句块，仅在该类第一次被加载时执行

Q：final关键字
A：final关键字可以用来修饰变量、方法和类。
   当final修饰基本数据类型时，该变量就成了常量，值无法改变
   当final修饰引用数据类型时，该变量的值不能改变，即储存的地址不变，不能再去指向别的对象，但对象内的成员可以改变
	用final修饰的类称为最终类，该类不能被继承，其中的方法自动成为final方法，不包括属性
	用final修饰的方法不能被子类覆盖
	用final修饰方法的参数，表示该方法不期望该参数传进来后有任何改变

Q：封装性
A：可见度：同一个类中、同一个包中、不同包的子类、不同包的非子类
   权  限:private、default、protected、public
   类能使用的访问修饰符只有default和public
   类成员能使用四种

Q:继承性
A:子类继承父类的成员变量，当子类继承了某个类之后，便可以使用父类中的成员变量，但是并不是完全继承父类的所有成员变量
　1）能够继承父类的public和protected成员变量；不能够继承父类的private成员变量；
　2）对于父类的default成员变量，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
　3）对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，
		即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。
		
　子类继承父类的方法，同样地，子类也并不是完全继承父类的所有方法。
　1）能够继承父类的public和protected成员方法；不能够继承父类的private成员方法；
　2）对于父类的default成员方法，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
　3）对于子类可以继承的父类成员方法，如果在子类中出现了同名称的成员方法，则称为覆盖，
		即子类的成员方法会覆盖掉父类的同名成员方法。如果要在子类中访问父类中同名成员方法，需要使用super关键字来进行引用。
		
　注意：隐藏和覆盖是不同的。隐藏是针对成员变量和静态方法的，而覆盖是针对普通方法的。
  覆盖只针对非静态方法（终态方法不能被继承，所以就不存在覆盖一说了），而隐藏是针对成员变量和静态方法的。
  这2者之间的区别是：覆盖受RTTI（Runtime type  identification）约束的，而隐藏却不受该约束。
  也就是说只有覆盖方法才会进行动态绑定，而隐藏是不会发生动态绑定的。除了static方法和final方法，其他所有的方法都是动态绑定

  
Q：向上转型，强制类型转换
A：Father father = new Son(); 
			father是Father类的对象，变量是Father的，但方法是Son类的。在内存中本质还是Son类型的，
			只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！
      Son son = (Son)father;
			这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，
			将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。
			
	当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。
		Father father = new  Father();
		Son son = (Son) father;
		所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。		
		在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。
		
   子类可以向父类进行类型转型，使父类的的对象能引用子类的对象，父类的对象是通过实例化一个子类的对象而来的。
   向上转型后的对象是父类对象，没法调用子类的成员方法和成员变量，但如果存在同名的方法，也就是方法覆盖，父类的方法会被子类覆盖
   动态方法调度机制仅对方法有效，如果存在同名的变量，调用的还是父类的变量，可以通过调用被子类覆盖的方法访问子类的变量

   
Q：多态性，方法重载Overloading，方法覆盖Overriding
A：方法重载Overloading，又称静态多态性，方法名以及参数列表称为方法的签名，不同的方法，签名必须不同，方法重载要求方法名相同，
	那么参数列表不能相同，返回类型不是方法签名的一部分。
   方法覆盖Overriding，又称动态多态性，调用方式为动态绑定，子类对父类方法重新定义，但方法名、返回类型和参数列表要求一样。
   允许子类将覆盖方法的返回类型定义为原返回类型的子类型。子类方法不能缩小访问权限！	
   父类静态方法不能被覆盖！私有方法不能被覆盖！final修饰的方法不能被覆盖！这三种是静态绑定

   
Q：抽象类
A：抽象类是专门设计用来让子类继承的类，提供一个类的部分实现，其内部可以有成员变量、构造方法、具体方法和抽象方法。
   抽象方法以分号结束！abstract 返回类型 方法名（参数列表）;
   抽象类不会有实例，在JDK1.8可以有main方法，可以运行，可以有构造方法
   对于类，不能同时用final和abstract说明，
   对于成员方法，不能同时用static和abstract说明，因为使用static关键字的方法能在不实例化对象时就被使用，
   而abstract的方法没有方法体，必须靠子类具体实现

   
Q：接口
A：接口不是类，而是对类的一组需求描述，由常量和抽象方法组成，
   [public] interface 接口名 [extends...]{
	数据类型 变量名 = 常量值；
	返回类型 方法名（参数列表）;
   }
   接口具有继承性，可以继承多个父接口，用逗号隔开，interface C extends A,B{...}
   默认接口中所有成员变量的修饰都是加上public、static、final
   默认接口中所有成员方法都是public、abstract，
   only public, abstract, default, static and strictfp are permitted，如果改成default或static就要添加方法体，不是抽象方法了
   only one of abstract, default, or static permitted
   接口本身具有抽象属性，加不加abstract都可以，访问控制权限只有public和default	   
   同一个Java源文件只能有一个public修饰的类或接口
   接口不含构造方法，不能直接通过接口生成接口
   实际测试jdk8：接口可以有main方法，可以运行，不能用new实例化
		 可以有静态方法，要有方法体，此时已不是抽象方法，可以在main里面直接调用运行
		 可以有default修饰的方法，必须有方法体，此时已不是抽象方法
   当一个类实现了一个接口，就必须实现其中所有的方法，就是方法覆盖，由于方法覆盖不能缩小父类方法的访问权限，
	而接口方法默认public，实现的方法也必须是public
   接口回调，interface A{} class B implements A{}  A a = new B();
	a被定义成接口A类型，被一个B实例赋值，只有接口定义声明的方法，
	那B的属性以及其他方法呢，如果它实现接口声明的方法中有其他属性和方法呢，实践证明都是可以在接口声明的方法里用

	
Q：内部类
A：如果类B被定义在类A内，那么类B就是一个内部类，它为类A所知，不被类A的外界所知，类B可以访问类A的成员，包括private成员。
	内部类的类名只用于定义它的类或语句块中，在外部引用必须给出带外部类的完整名称。
	内部类的名字不允许与外部类的名字相同。
	内部类可以是抽象类或接口，若是接口，则可以由其他内部类实现。
    按照内部类是否有显示的类名来划分为  实名内部类和匿名内部类
	  实名内部类可以有四种访问控制方式，可以有static称为静态实名内部类，创建格式为：new 外部类名.实名内部类名（参数列表）
	      没有static的称为不具有静态属性的实名内部类，它的成员变量若有静态属性，则必须有final属性，但成员方法不能有静态属性，
		  创建格式：外部类实例对象.new 实名内部类名（参数列表）
	      访问静态属性的成员：外部类名.实名内部类名.静态成员
              访问不具有静态属性的成员：实名内部类实例对象.成员
      	  匿名内部类，不具有类名，且类不具有抽象和静态属性，也不能排生出子类，
		  定义格式：new 父类名（父类型的构造方法的参数列表）{...}
	      优点1.进一步实现多重继承，可以使用接口实现多重继承，但必须实现接口里所有方法，而通过内部类就没这个问题
		  2.能更好地解决接口和父类中方法的同名冲突，即通过一个内部类来实现接口，本类继承父类
		  3.隐藏程序实现的细节
		  4.能够无条件访问外部类的成员


Q：反射
A：主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。
	在java中，通过反射，能够在"运行态"动态获得任意一个类的所有属性和方法，动态地调用对象的方法。

	在程序运行期间，系统始终为所有的对象维护一个被称为运行时的类型标识，这个信息跟踪每个对象所属的类。
	可以通过专门的Java类访问这些信息，保存这些信息的类被称为Class，有三种方法获取Class
	1.对象的getClass()方法会返回一个Class类型的实例。
	2.类.class返回一个Class类型的实例。
	3.对象的getName()方法会返回类的包名类名，可以通过Class的静态方法forName(String name)得到类名对应的Class对象。
	

	可以用Class的newInstance()方法快速创建一个类的实例
	getFields、getMethods、getConstructors方法分别返回类提供的public属性、方法和构造器数组，包括超类的公有成员
	要是其中加了Declare，如getDeclareFields方法，将返回类中声明的全部属性、方法和构造器，但不包括超类的成员

	检查类的结构：有三个类Field、Method、Constructor分别描述类的属性、方法和构造方法
	Modifier类可以分析修饰符，getModifiers()方法获得调用它的类或属性或方法的修饰符,用它的toString(int mod)方法将修饰符打印输出

	运行时查看属性的实际内容：class.getDeclareField(属性名).get(对象名)，不能看私有属性，要查看得加上Field.setAccessible(true)
	可以获得就可以设置，Field.set(对象名，值)

	调用方法：先得到指定方法名getMethod(String name,Class...parameterTypes)，调用invoke(Object obj,Object...args)
	method.invoke(对象名，参数s)，若是静态方法，则对象名为null


Q：多线程、多进程
A：一个程序同时执行多个任务，每个任务称为一个线程thread，区别，每个进程拥有自己的一整套变量，而线程则共享数据。

   在Java中创建线程有两种方法：继承Thread类或实现Runnable接口。在使用Runnable接口时需要建立一个Thread实例。
   因此，无论是通过Thread类还是Runnable接口建立线程，都必须建立Thread类或它的子类的实例。都需要覆盖run()方法。
   
   线程状态：
   New(新创建)：new Thread()创建了一个新的线程对象。程序没有开始运行线程中的代码。
   Runnable(可运行)：调用start()方法，一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程的运行时间。
   Blocked(被阻塞)：暂时不活动。当一个线程试图获取一个内部的对象锁，而该锁被其他线程持有，则进入阻塞状态。
   Waiting(等待)：暂时不活动。当线程等待另一个线程通知调度器一个条件时，进入等待状态。	
   Timed Waiting(计时等待)：有几个方法有一个超时参数，调用这些方法会使线程进入计时等待状态，直到超时期或接收到适当的通知。	
   Terminated(被终止)：有两个原因会导致终止，1.因run方法正常退出而自然死亡。2.因为一个没有捕获的异常终止了run方法而意外死亡。
   
   线程属性：
	线程优先级：每一个线程都有优先级，默认继承父线程的优先级，可通过setPriority方法设置。每当线程调度器有机会选择新线程时，
			   它首先选择较高优先级的线程，但线程优先级高度依赖操作系统，要看宿主机平台的线程实现机制。
	守护线程：通过调用setDaemon(true)将线程转为守护线程。其唯一用途是为其他线程提供服务，例如计时线程。当只剩下守护线程时，
			 虚拟机就退出了。
	处理未捕获异常的处理器：不被检测的异常会导致线程终止，在线程死亡之前，异常被传递到一个用于未捕获异常的处理器，
						   通过setUncaughtExceptionHandler方法来为线程安装一个处理器，默认为空。
	线程组：如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。线程组是一个可以统一管理的线程集合。
		   ThreadGroup类实现了Thread.UncaughtExceptionHandler接口，按顺序选择下面一个操作：
				1.如果该线程组有父线程组，则调用父线程组的uncaughtException方法
				2.如果Thread.getDefaultExceptionHandler方法返回一个非空的处理器，则调用它
				3.如果Throwable是ThreadDeath的一个实例，什么都不做
				4.线程的名字以及Throwable的栈踪迹被输出到System.err上

   同步：两个或两个以上的线程需要共享同一数据的存取，可能会产生错误。这个情况成为竞争条件。
	
   

   
   
   
   
Q：集合类（有序的意思是根据添加的顺序存放）
A：Collection接口是集合接口树的根。java提供了一个操作Set、List、Map等集合的工具类：Collections，
	该工具类里提供了大量方法对集合进行排序、查询、修改等操作，还提供了将集合对象设置为不可变、对集合对象实现同步控制等方法。

	Set接口无序不重复：
		HashSet是Set接口的典型实现，是最常用的Set实现类，当向其中存一个元素的时候，HashSet会调用该对象的hashCode()方法
		得到该对象的hashCode值（伪地址），然后根据hashCode值向相应的内存中存放元素。如果两个元素的equals相等而它们的hashCode值
		不同，则HashSet会将它们存放在不同的位置。如果它们的hashCode值相同，但是equals返回值不同，HashSet会在这个位置用链式结构
		保存多个元素（相当于Hash用链表防止冲突），这样会导致性能下降，所以一般在重写equals方法的时候，也应该重写hashCode方法。
		如果hashcode值相同，equals也返回true，则不能重复添加，只显示一个。
		
		LinkedHashSet原理实现和HashSet基本相同，不同的是它除了根据对象的hashCode值决定存放位置，
		还使用了链表来维护元素的次序，所以是有序存放的。
		
		TreeSet是SortedSet接口的实现类,它的数据结构采用的是红黑树，所以它可以对元素进行排序，但元素是不重复的。
		而且提供了comparator方法可以定制排序，当不使用comParator方法时，它是根据元素的compareTo方法来判断元素大小的，
		所以在使用TreeSet的时候，如果要重写equals方法，应该注意其compareTo方法也要重写；
		
		HashSet是最常用的，但是其具有不重复无序的特点，
		LinkedHashSet由于采用链式维护，所以其是有序的，但性能降低了；
		TreeSet由于需要额外的红黑树来维护集合元素的次序，所以其性能不好，但是如果集合元素需要排序可以考虑用TreeSet;
	
	List接口有序可重复：
		ArrayList与Vector作为List类的两个典型实现，基本功能是一样，只不是Vector出现的早点，ArrayList是后来出现在的，
		所以ArrayList的方法名可以短一些，两者实现的原理都是封装了一个动态的、允许再分配的Object[]数组，
		另外ArrayList是线程不安全的，Vector是线程安全的，所以通常尽量少用Vector.

		LinkedList也是List的实现类，它是一个基于链表实现的List类，对于迭代访问，插入、删除的速度非常快，
		但是如果如果根据索引拿取元素，它就不那么快了，这时应该用ArrayList；另外LinkedList还实现了Deque接口，
		因此它可以被当成双端队列来使用，自然也可以被当成“栈”来使用，因此现在的程序中需要使用“栈”这种数据结构时，
		推荐使用ArrayDeueue或LinedList，而不是Stack；
		
		一些操作：添加add() 移除remove(index) 得到get(index) 修改set(index,"") 元素数size() 打乱顺序Collections.shuffle(list)
		
	Map接口键值对形式：
		Map是用来保存具有映射关系的数据，是一个无序不可重复的集合，相当于“关联数组”；Set和Map的关系十分密切，
		java源码就是先实现了HashMap、TreeMap等集合，然后通过包装一个所有的value都为null的Map集合实现了Set集合类，
		所以呢在说Map的时候key值几乎和我们说的set一模一样，所以相似的我就不多提了
	
		Hashtable与HashMap，光看名字就知道Hashtable是一个很古老的实现类，因为他的名字都没有符合驼峰命名规范，
		而HashMap就是它的替代类，跟ArraySet和Vector一样，HashMap是线程不安全的而Hashtable是线程安全的，但不建议用Hashtable，
		如果需要同步可以用Collection工具类来进行包装。它们另个一个区别是HashMap里面的key和value值都可以为null，而Hashtable不可以

		LinkedHashMap和LinkedHashSet一样，是用了一个双链表来维护key-value队伍次序，所以它可以实现有序插入，但是性能必然降低了。
		
		TreeMap实现了SortedMap接口，当然功能也和TreeSet相似，可以自然排序也可以定制排序（排序的对象是Key值）
		

Q：关于输入输出流I/O
A：流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，
     根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 

	  抽象类InputStream和OutputStream构成了输入/输出类层次结构的基础。
	  （字节流不便处理Unicode编码的信息，因为其每个字符用了多个字节来表示。所以有单独的类层次结构处理它，都是基于两字节的。）
	  
	  抽象方法read()和write()是最基础的，读写一个字节，在执行时都将阻塞，直至字节确实被读入或者写出。
	  
	  完成对流的读写时应该调用close()来关闭，释放系统资源。关闭输出流的同时还会冲刷其缓冲区，也可用flush()来手动冲刷。
   
	字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 
	字节流Byte和字符流Char的区别：
		读写单位不同：字节流以字节（1Byte = 8bit）为单位，字符流以字符为单位，一次可能读多个字节，根据指定的编码表映射字符。
		处理对象不同：字节流能处理所有类型的数据（如图片、avi、MP3等），而字符流只能处理字符类型的数据。
	结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。
  
	读取时的字节数组或字符数组的长度如何确定？
  
	缓冲区的作用：
	用了BufferedInputStream后你每次读取都是从缓冲区里拷贝数据，缓冲区没东西了就调IO从数据源读到缓冲区，然后你再从缓冲区读。
	为什么会这样呢，因为你自己建立的数组大小和缓冲区大小一样，根本就没起到缓冲作用。
	当你程序的数组小于缓冲区的时候才会起到缓冲作用。
	比如是byte[] b=new byte[2048];，你要读的数据是1M，那么你要调512次IO，假设一次1s，就512s，
	但如果用BufferedInputStream，你每从缓冲区读取4（8192/2048=4）次才调用一次IO（假设访问内存一次0.1s），总共要128次，就128s，
	加上总的从缓冲区拷贝数据的时间（512*0.1=51.2s），128+51.2=179.2。这里用0.1s和1s来体现IO很耗时
  
    使用字节流读写文件：FileInputStream、FileOutputStream   
   
    使用带缓冲的字节流读写：字节流+BufferedInputStream、字节流+BufferedOutputStream

    使用字符流读写：字节流+InputStreamReader、字节流+OutputStreamWriter  
   
    使用带缓冲的字符流读写：字符流+BufferedReader、字符流+BufferedWriter

    文件读取类FileReader extends InputStreamReader
    文件输出类FileWriter extends OutputStreamWriter   
		已经是字符流了，只能处理纯文本数据，但并没有实现父类中带字符集参数的构造函数，所以仅能按系统默认的字符集编解码。所以不推荐，还是用父类好。

		PrintWriter和其他Writer的区别：其他Writer没有相关的格式化的方法，而PrintWriter可以在写入同时对写入的数据进行格式化。

Q：对象序列化
A：可以将任何对象写出到流中，也可以从流中读回。可以将对象保存到磁盘中，或者通过网络传输。
     每个对象都有一个序列号，用以代替原生的内存地址。

Q：什么是Java？
A：Java编程语言是个简单、完全面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的编程语言。

Q：JDBC连接数据库的步骤：
	加载驱动程序 Class.forName("com.ibm.db2.jcc.DB2Driver");
	与数据库建立连接 Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/jsp_db","admin","admin");
	执行查询，发送SQL语句 Statement stmt = con.creatStatement();
	获取结果集 ResultSet rs = stmt.executeQuery("SELECT * FROM user");
		   while(rs.next()){
			String s = rs.getString("name");
		   }
	关闭连接，清理环境


Q:面向对象编程是什么，有什么优点，和面向过程有什么区别？
A:面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了，数据和对数据的操作是分开的。
面向对象是把某些事物分解成各个对象，将数据和方法封装在一个整体（类）里面，操作时只要调用对象的方法即可，不用关注具体过程。
优点：	1.代码开发模块化，更易维护和修改。2.代码复用。3.增强代码的可靠性和灵活性。4.增加代码的可理解性。
面向对象编程有四大重要的特性： 封装，继承，多态和抽象


Q：封装，多态，继承，抽象的解释？
A：封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。好处:1.通过隐藏对象的属性来保护对象内部的状态。2.提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。3.禁止对象之间的不良交互提高模块化。
多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。
表现形式主要有两种：方法重载Overloading，又称静态多态性，同一类中允许多个同名方法，但要求参数个数不同或参数类型不同或参数顺序不同。方法覆盖Overriding，又称动态多态性，子类对父类方法重新定义，但方法名、返回值和参数形态完全一样。
继承给对象提供了从父类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。
抽象是把想法从具体的实例中分离出来的步骤，这种抽象技术的主要目的是把类的行为和实现细节分离开。
抽象和封装的不同点。抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。


Q：JDK、JRE、JVM？什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
A：Java虚拟机（JVm）是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。
Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，是Java实现跨平台的关键，因为它知道底层硬件平台的指令长度和其他特性。
Java运行时环境(JRE)包含将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。
Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。


Q：“static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？
A：“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
Q：是否可以在static环境中访问非static变量？
static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。


Q：Java支持的数据类型有哪些？什么是自动拆装箱？
A：Java语言支持的8中基本数据类型是：
boolean、char、byte、short、int、long、float、double
自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。


Q：接口和抽象类的区别是什么？
A：Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
类可以实现很多个接口，但是只能继承一个抽象类
类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
抽象类可以在不提供接口方法实现的情况下实现接口。
Java接口中声明的变量默认都是static final的，不过接口一般不定义变量。抽象类可以包含非final的变量。
Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。


Q：什么是值传递和引用传递？
A：对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。
对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。


Q：进程和线程的区别是什么？
A：进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。
Q：县城的启动方式是start还是run？
A：Thread a = new Thread(); a.start();
   或者 class XC implements Runnable{ XC b = new XC();Thread c = new Thread(b); c.start(); }
Q：创建线程有几种不同的方式？你喜欢哪一种？为什么？
A：有三种方式可以用来创建线程：
继承Thread类
实现Runnable接口
应用程序可以使用Executor框架来创建线程池
实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。
在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。
同时，线程池也是非常高效的，很容易实现和使用。


Q：概括的解释下线程的几种可用状态。
A：线程在执行过程中，可以处于下面几种状态：
就绪(Runnable):线程准备运行，不一定立马就能开始执行。
运行中(Running)：进程正在执行线程的代码。
等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。
睡眠中(Sleeping)：线程被强制睡眠。
I/O阻塞(Blocked on I/O)：等待I/O操作完成。
同步阻塞(Blocked on Synchronization)：等待获取锁。
死亡(Dead)：线程完成了执行。


Q：Java集合类框架的基本接口有哪些？
Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：
Collection：代表一组对象，每一个对象都是它的子元素。
Set：不包含重复元素的Collection。
List：有顺序的collection，并且可以包含重复元素。
Map：可以把键(key)映射到值(value)的对象，键不能重复。


Q：什么是迭代器(Iterator)？
Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的
迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。


Q：Iterator和ListIterator的区别是什么？
下面列出了他们的区别：
Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。


Q：HashMap和Hashtable有什么区别？
HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：
HashMap允许键和值是null，而Hashtable不允许键或者值是null。
Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。
一般认为Hashtable是一个遗留的类。


Q：数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？
下面列出了Array和ArrayList的不同点：
Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
Array大小是固定的，ArrayList的大小是动态变化的。
ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。


Q：ArrayList和LinkedList有什么区别？
ArrayList和LinkedList都实现了List接口，他们有以下的不同点：
ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。
相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。
LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。


Q：HashSet和TreeSet有什么区别？
HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。
另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。


Q：如何权衡是使用无序的数组还是有序的数组？
有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。


Q：Java集合类框架的最佳实践有哪些？
根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。
有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。
为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。
使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。
编程的时候接口优于实现。
底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。

Q:关于异常Exception
异常对象都是派生于Throwable类的一个实例。在下一层分成两个分支：Error和Exception。Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误，很少出现，一般不需要程序员处理。
需要关注的是Exception层次结构，又分解为两个分支：由程序错误导致的异常RuntimeException（错误的类型转换、数组越界、访问空指针等）
和程序没有问题但由于I/O错误这类问题导致的其他异常（在文件尾部后面读取数据、打开不存在的文件、根据给定的字符串查找不存在的Class对象）。
出现RuntimeException（不要关注这个名字）就一定是程序员的问题，应通过检测避免发生这类异常。
将派生于Error类或RuntimeException类的所有异常称为未检查异常，其他的称为已检查异常。编译器要求为所有已检查异常提供异常处理器。
也就是说除了不可控制的Error，程序员要避免发生RuntimeException的未检查异常，为其他的已检查异常提供异常处理器。
方法应该在其首部声明所有可能抛出的已检查异常（或者捕获）。例如public FileInputStream(String name) throws FileNotFoundException。
声明抛出的异常如果是某个特定类的实例时，可能抛出一个这个类的异常或者这个类的任意一个子类的异常。例如声明抛出IOException异常，既可能是IOException异常，
也可能是其子类异常例如FileNotFoundException。
抛出异常异常类：1.找到一个合适的异常类。2.创建这个类的一个对象。3.将对象抛出throw。一旦抛出，这个方法就不可能返回到调用者。
使用try...catch捕获异常并进行处理。通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常使用throws抛出，传递给它的调用者。

Q：throw和throws有什么区别？
throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。

Q：异常处理的时候，finally代码块的重要性是什么？(译者注：作者标题的序号弄错了)
无论是否抛出异常，finally代码块总是会被执行。就算是没有catch语句同时又抛出异常的情况下，finally代码块仍然会被执行。最后要说的是，finally代码块主要用来释放资源，比如：I/O缓冲区，数据库连接。

Q：异常处理完成以后，Exception对象会发生什么变化？
Exception对象会在下一个垃圾回收过程中被回收掉。

Q：finally代码块和finalize()方法有什么区别？
无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。

Q：什么是Servlet？
Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。

Q：说一下Servlet的体系结构。
所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。

Q：Applet和Servlet有什么区别？
Applet是运行在客户端主机的浏览器上的客户端Java程序。而Servlet是运行在web服务器上的服务端的组件。applet可以使用用户界面类，而Servlet没有用户界面，相反，Servlet是等待客户端的HTTP请求，然后为请求产生响应。

Q：GenericServlet和HttpServlet有什么区别？
GenericServlet是一个通用的协议无关的Servlet，它实现了Servlet和ServletConfig接口。继承自GenericServlet的Servlet应该要覆盖service()方法。最后，为了开发一个能用在网页上服务于使用HTTP协议请求的Servlet，你的Servlet必须要继承自HttpServlet。这里有Servlet的例子。

Q：解释下Servlet的生命周期。
对每一个客户端的请求，Servlet引擎载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet对象通过为每一个请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet的destroy()方法把Servlet删除掉。

Q：doGet()方法和doPost()方法有什么区别？
doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。
doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。

Q：什么是Web应用程序？
Web应用程序是对Web或者是应用服务器的动态扩展。有两种类型的Web应用：面向表现的和面向服务的。面向表现的Web应用程序会产生包含了很多种标记语言和动态内容的交互的web页面作为对请求的响应。而面向服务的Web应用实现了Web服务的端点(endpoint)。一般来说，一个Web应用可以看成是一组安装在服务器URL名称空间的特定子集下面的Servlet的集合。

Q：什么是cookie？session和cookie有什么区别？
cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：
无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。
在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。


Q：什么是JSP页面？
JSP页面是一种包含了静态数据和JSP元素两种类型的文本的文本文档。静态数据可以用任何基于文本的格式来表示，比如：HTML或者XML。JSP是一种混合了静态内容和动态产生的内容的技术。这里看下JSP的例子。


Q：JSP请求是如何被处理的？
浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结束，servlet会把响应发送给客户端。这里看下如何在JSP中获取请求参数。


Q：JSP有什么优点？
下面列出了使用JSP的优点：
JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。
JSP页面可以被预编译。
JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。
开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。
开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。


Q：什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？
Directive是当JSP页面被编译成Servlet的时候，JSP引擎要处理的指令。Directive用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive是定义在<%@ 和 %>之间的。下面列出了不同类型的Directive：
包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面。
页面指令(Page directive)：用来定义JSP页面中特定的属性，比如错误页面和缓冲区。
Taglib指令： 用来声明页面中使用的自定义的标签库。


111.什么是JSP动作(JSP action)？
JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作：
jsp:include-当JSP页面被请求的时候包含一个文件。
jsp:useBean-找出或者是初始化Javabean。
jsp:setProperty-设置JavaBean的属性。
jsp:getProperty-获取JavaBean的属性。
jsp:forward-把请求转发到新的页面。
jsp:plugin-产生特定浏览器的代码。







