Q:Java标识符由哪些组成？首字符可以是什么？
A：标识符的组成：1.字母 2.数字 3.下划线“_” 4.美元符号$  首字母不能是数字、Java关键字不能做标识符如public,private,package
   所谓的字母是广义的，中文也可以，如“你好”可以作为标识符 
   Java有50个关键字，其中const和goto作为保留字,true、false、null不是严格意思上的Java关键字，main不是关键字

Q:基本数据类型之间的类型转换
A：布尔型boolean与其他基本数据类型不可互相转换。
   字符型char与字节型byte、短整型short之间可以进行强制类型转换，没有强弱之分
   byte < short < int < long < float < double

   byte是字节数据类型，是有符号型的，占1个字节(8个位)；大小范围为-128—127
   char是字符数据类型，是无符号型的，占2字节(Unicode码 ）；大小范围 是0—65535，JAVA用char来表示单个字符。
   如'u','+','中'需要用单引号括起来，整数不用
   
   输出时，byte会都转换成整数，char转为字符
   
Q:基本数据类型的默认值？
A:若基本数据类型作为类成员变量的时候，即使没有进行初始化。java也会给定默认的初始值。数值为0，布尔型为false
  但是在方法中声明一个变量，可能是任意值，会报错，不会初始化为默认值
   
Q:运算符
A:在取模运算%中，结果的符号与第一个操作数的符号相同， 11 % -5 = 1
  j=j++;运算顺序是先j增加1，然后把j原来的值赋给自己，所以j不变
  <、<=、>、=>只能用来比较基本数据类型（除了boolean），==、!=可以用在基本和引用数据类型上 

Q：==和equals()方法的区别？
A：1、值类型是存储在内存中的堆栈（简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。
　 2、==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。
　 3、equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同，左边不能用于基本数据类型，右边可以自动装箱
　 4、==比较的是2个对象的地址，而equals比较的是2个对象的内容，显然，当equals为true时，==不一定为true。
	总结：==比较的是栈中的内容是否相同，equals()方法比较的是堆中的内容是否相同，比较前先分清堆和栈中的内容是什么！
   ||（条件或）和 &&（条件与）具有 短路规则
   
Q：关于String字符串
A：String是不可变字符串，有一个优点：编译器可以让字符串共享。有一个字符串常量池。在编译期确定，存入.class文件
   通过String a = "abc";创建的都是字符串常量，在编译期内确定，只要内容相同，地址也相同。String b = "a" + "bc";也是字符串常量
		而 b+="abc" 或substring等操作不能在编译期确定，得到的结果不是字符串常量，地址不同。
   通过new String();创建的都不是字符串常量，不能在编译期确定.
   
   空串与Null串
   空串""是一个Java对象，有长度（0），有内容（空），判断 str.length()==0 或 str.equals("")
   Null串中放了一个特殊的值Null，表示目前没有任何对象与该变量关联，判断 str == null

Q:关于switch语句
A:对表达式计算，再与每个case子句中的常量值比较，匹配成功则执行该case子句后的语句，直到遇到break为止。
  要注意表达式必须是符合byte、char、short、int类型的表达式，不能使用浮点型或long类型或字符串（新版java支持字符串）

Q:Java支持哪三种跳转语句？
A:break、continue 和 return 
  break有三种作用 1.被用来终止switch 2.终止for、while循环 3.跳出带标号的语句块
  continue语句只结束本次循环，而break是结束整个循环语句的执行
  return语句的作用是终止当前方法的执行，返回到这个方法的调用者

Q:类的加载与对象的初始化
A:当程序执行时，需要生成某个类的对象，Java执行引擎会先检查是否加载了这个类，如果没有加载，则先执行类的加载再生成对象，
  在类的加载过程中，类的static成员变量会被初始化，如果类中有static语句块，则会执行static语句块。
	初始化static成员变量和执行static语句块的顺序同代码中的顺序一致。记住，在Java中，类是按需加载，只有当需要用到这个类的时候，
	才会加载这个类，并且只会加载一次。
  在生成对象的过程中，会先初始化对象的成员变量，然后再执行块，再执行构造器。
  父类加载-->子类加载-->父类初始化-->子类初始化

Q：关于构造方法
A：修饰符可以有访问权限的修饰词（4种），不能有其他如abstract、final、native、static或synchronized
   方法名即类名，可以有任意个参数，没有返回类型也没有void
   默认有一个无参构造方法，但如果已经有了定义的构造方法，系统不会创建这个默认无参构造方法

Q：构造方法的继承性
A：构造方法是从定向下进行调用的，子类的构造方法中必须要通过super关键字在第一行调用父类的构造方法，
	如果调用的是父类无参构造方法，可省略super()，系统会自动加上
	如果调用父类有参构造方法，必须显式调用super(...)，确保子类在初始化前父类会被实例化
   父类的构造器调用以及初始化过程一定在子类的前面。	
   
Q：关于main方法
A：修饰符public 因为main方法是JVM自动调用的，需要让JVM可见
   static：由于main是所有程序的入口，被调用时没有任何对象创建，要想不通过对象调用某一方法，只有将该方法定义为static方法
   void：JVM对于Java程序来说已经是系统的最底层，由它调用的方法的返回值无处可去
   String args[]：能够接收命令行传入的参数

Q：方法参数的传递
A：★java中的变量有两种类型：引用类型(对象)和基本数据类型。当他们被作为参数传递给方法时，他们都是传值的副本或者引用地址的副本！

Q: static关键字
A：类变量和类方法的调用，直接 类名.类变量  类名.类方法（【参数列表】）
   两条重要原则：1.类方法不能访问所属类的非静态变量和方法，只能访问方法体内的局部变量、参数和静态变量
	             2.类方法中不能出现this和super关键字
   static修饰的变量和方法能独立于任何对象，因此某一个对象修改了类变量的值，会导致所有对象中的类变量一起发生改变，
   因为所有的对象中的类变量仅仅存放的是一个引用值，该引用值都是指向类变量真正存放的静态存储区的内存地址
   如果要通过计算来初始化static变量，可以声明一个static语句块，仅在该类第一次被加载时执行

Q：final关键字
A：final关键字可以用来修饰变量、方法和类。
   当final修饰基本数据类型时，该变量就成了常量，值无法改变
   当final修饰引用数据类型时，该变量的值不能改变，即储存的地址不变，不能再去指向别的对象，但对象内的成员可以改变
	用final修饰的类称为最终类，该类不能被继承，其中的方法自动成为final方法，不包括属性
	用final修饰的方法不能被子类覆盖
	用final修饰方法的参数，表示该方法不期望该参数传进来后有任何改变

Q：封装性
A：可见度：同一个类中、同一个包中、不同包的子类、不同包的非子类
   权  限:private、default、protected、public
   类能使用的访问修饰符只有default和public
   类成员能使用四种

Q:继承性
A:子类继承父类的成员变量，当子类继承了某个类之后，便可以使用父类中的成员变量，但是并不是完全继承父类的所有成员变量
　1）能够继承父类的public和protected成员变量；不能够继承父类的private成员变量；
　2）对于父类的default成员变量，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
　3）对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，
		即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。
		
　子类继承父类的方法，同样地，子类也并不是完全继承父类的所有方法。
　1）能够继承父类的public和protected成员方法；不能够继承父类的private成员方法；
　2）对于父类的default成员方法，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
　3）对于子类可以继承的父类成员方法，如果在子类中出现了同名称的成员方法，则称为覆盖，
		即子类的成员方法会覆盖掉父类的同名成员方法。如果要在子类中访问父类中同名成员方法，需要使用super关键字来进行引用。
		
　注意：隐藏和覆盖是不同的。隐藏是针对成员变量和静态方法的，而覆盖是针对普通方法的。
  覆盖只针对非静态方法（终态方法不能被继承，所以就不存在覆盖一说了），而隐藏是针对成员变量和静态方法的。
  这2者之间的区别是：覆盖受RTTI（Runtime type  identification）约束的，而隐藏却不受该约束。
  也就是说只有覆盖方法才会进行动态绑定，而隐藏是不会发生动态绑定的。除了static方法和final方法，其他所有的方法都是动态绑定

  
Q：向上转型
A：Father aa = new Sub();  aa是Father类的对象，但方法是Sub类的
   子类可以向父类进行类型转型，使父类的的对象能引用子类的对象，父类的对象是通过实例化一个子类的对象而来的。
   向上转型后的对象是父类对象，没法调用子类的成员方法和成员变量，但如果存在同名的方法，也就是方法覆盖，父类的方法会被子类覆盖
   动态方法调度机制仅对方法有效，如果存在同名的变量，调用的还是父类的变量，可以通过调用被子类覆盖的方法访问子类的变量

   
Q：多态性，方法重载Overloading，方法覆盖Overriding
A：方法重载Overloading，又称静态多态性，方法名以及参数列表称为方法的签名，不同的方法，签名必须不同，方法重载要求方法名相同，
	那么参数列表不能相同，返回类型不是方法签名的一部分。
   方法覆盖Overriding，又称动态多态性，调用方式为动态绑定，子类对父类方法重新定义，但方法名、返回类型和参数列表要求一样。
   允许子类将覆盖方法的返回类型定义为原返回类型的子类型。子类方法不能缩小访问权限！	
   父类静态方法不能被覆盖！私有方法不能被覆盖！final修饰的方法不能被覆盖！这三种是静态绑定

   
Q：抽象类
A：抽象类是专门设计用来让子类继承的类，提供一个类的部分实现，其内部可以有成员变量、构造方法、具体方法和抽象方法。
   抽象方法以分号结束！abstract 返回类型 方法名（参数列表）;
   抽象类不会有实例，在JDK1.8可以有main方法，可以运行，可以有构造方法
   对于类，不能同时用final和abstract说明，
   对于成员方法，不能同时用static和abstract说明，因为使用static关键字的方法能在不实例化对象时就被使用，
   而abstract的方法没有方法体，必须靠子类具体实现

   
Q：接口
A：接口不是类，而是对类的一组需求描述，由常量和抽象方法组成，
   [public] interface 接口名 [extends...]{
	数据类型 变量名 = 常量值；
	返回类型 方法名（参数列表）;
   }
   接口具有继承性，可以继承多个父接口，用逗号隔开，interface C extends A,B{...}
   默认接口中所有成员变量的修饰都是加上public、static、final
   默认接口中所有成员方法都是public、abstract，
   only public, abstract, default, static and strictfp are permitted，如果改成default或static就要添加方法体，不是抽象方法了
   only one of abstract, default, or static permitted
   接口本身具有抽象属性，加不加abstract都可以，访问控制权限只有public和default	   
   同一个Java源文件只能有一个public修饰的类或接口
   接口不含构造方法，不能直接通过接口生成接口
   实际测试jdk8：接口可以有main方法，可以运行，不能用new实例化
		 可以有静态方法，要有方法体，此时已不是抽象方法，可以在main里面直接调用运行
		 可以有default修饰的方法，必须有方法体，此时已不是抽象方法
   当一个类实现了一个接口，就必须实现其中所有的方法，就是方法覆盖，由于方法覆盖不能缩小父类方法的访问权限，
	而接口方法默认public，实现的方法也必须是public
   接口回调，interface A{} class B implements A{}  A a = new B();
	a被定义成接口A类型，被一个B实例赋值，只有接口定义声明的方法，
	那B的属性以及其他方法呢，如果它实现接口声明的方法中有其他属性和方法呢，实践证明都是可以在接口声明的方法里用

	
Q：内部类
A：如果类B被定义在类A内，那么类B就是一个内部类，它为类A所知，不被类A的外界所知，类B可以访问类A的成员，包括private成员。
	内部类的类名只用于定义它的类或语句块中，在外部引用必须给出带外部类的完整名称。
	内部类的名字不允许与外部类的名字相同。
	内部类可以是抽象类或接口，若是接口，则可以由其他内部类实现。
    按照内部类是否有显示的类名来划分为  实名内部类和匿名内部类
	  实名内部类可以有四种访问控制方式，可以有static称为静态实名内部类，创建格式为：new 外部类名.实名内部类名（参数列表）
	      没有static的称为不具有静态属性的实名内部类，它的成员变量若有静态属性，则必须有final属性，但成员方法不能有静态属性，
		  创建格式：外部类实例对象.new 实名内部类名（参数列表）
	      访问静态属性的成员：外部类名.实名内部类名.静态成员
              访问不具有静态属性的成员：实名内部类实例对象.成员
      	  匿名内部类，不具有类名，且类不具有抽象和静态属性，也不能排生出子类，
		  定义格式：new 父类名（父类型的构造方法的参数列表）{...}
	      优点1.进一步实现多重继承，可以使用接口实现多重继承，但必须实现接口里所有方法，而通过内部类就没这个问题
		  2.能更好地解决接口和父类中方法的同名冲突，即通过一个内部类来实现接口，本类继承父类
		  3.隐藏程序实现的细节
		  4.能够无条件访问外部类的成员


Q：反射
A：主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。
	在java中，通过反射，能够在"运行态"动态获得任意一个类的所有属性和方法，动态地调用对象的方法。

	在程序运行期间，系统始终为所有的对象维护一个被称为运行时的类型标识，这个信息跟踪每个对象所属的类。
	可以通过专门的Java类访问这些信息，保存这些信息的类被称为Class，有三种方法获取Class
	1.对象的getClass()方法会返回一个Class类型的实例。
	2.类.class返回一个Class类型的实例。
	3.对象的getName()方法会返回类的包名类名，可以通过Class的静态方法forName(String name)得到类名对应的Class对象。
	

	可以用Class的newInstance()方法快速创建一个类的实例
	getFields、getMethods、getConstructors方法分别返回类提供的public属性、方法和构造器数组，包括超类的公有成员
	要是其中加了Declare，如getDeclareFields方法，将返回类中声明的全部属性、方法和构造器，但不包括超类的成员

	检查类的结构：有三个类Field、Method、Constructor分别描述类的属性、方法和构造方法
	Modifier类可以分析修饰符，getModifiers()方法获得调用它的类或属性或方法的修饰符,用它的toString(int mod)方法将修饰符打印输出

	运行时查看属性的实际内容：class.getDeclareField(属性名).get(对象名)，不能看私有属性，要查看得加上Field.setAccessible(true)
	可以获得就可以设置，Field.set(对象名，值)

	调用方法：先得到指定方法名getMethod(String name,Class...parameterTypes)，调用invoke(Object obj,Object...args)
	method.invoke(对象名，参数s)，若是静态方法，则对象名为null


Q：多线程、多进程
A：一个程序同时执行多个任务，每个任务称为一个线程thread，区别，每个进程拥有自己的一整套变量，而线程则共享数据。

   在Java中创建线程有两种方法：继承Thread类或实现Runnable接口。在使用Runnable接口时需要建立一个Thread实例。
   因此，无论是通过Thread类还是Runnable接口建立线程，都必须建立Thread类或它的子类的实例。都需要覆盖run()方法。
   
   线程状态：
   New(新创建)：new Thread()创建了一个新的线程对象。程序没有开始运行线程中的代码。
   Runnable(可运行)：调用start()方法，一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程的运行时间。
   Blocked(被阻塞)：暂时不活动。当一个线程试图获取一个内部的对象锁，而该锁被其他线程持有，则进入阻塞状态。
   Waiting(等待)：暂时不活动。当线程等待另一个线程通知调度器一个条件时，进入等待状态。	
   Timed Waiting(计时等待)：有几个方法有一个超时参数，调用这些方法会使线程进入计时等待状态，直到超时期或接收到适当的通知。	
   Terminated(被终止)：有两个原因会导致终止，1.因run方法正常退出而自然死亡。2.因为一个没有捕获的异常终止了run方法而意外死亡。
   
   线程属性：
	线程优先级：每一个线程都有优先级，默认继承父线程的优先级，可通过setPriority方法设置。每当线程调度器有机会选择新线程时，
			   它首先选择较高优先级的线程，但线程优先级高度依赖操作系统，要看宿主机平台的线程实现机制。
	守护线程：通过调用setDaemon(true)将线程转为守护线程。其唯一用途是为其他线程提供服务，例如计时线程。当只剩下守护线程时，
			 虚拟机就退出了。
	处理未捕获异常的处理器：不被检测的异常会导致线程终止，在线程死亡之前，异常被传递到一个用于未捕获异常的处理器，
						   通过setUncaughtExceptionHandler方法来为线程安装一个处理器，默认为空。
	线程组：如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。线程组是一个可以统一管理的线程集合。
		   ThreadGroup类实现了Thread.UncaughtExceptionHandler接口，按顺序选择下面一个操作：
				1.如果该线程组有父线程组，则调用父线程组的uncaughtException方法
				2.如果Thread.getDefaultExceptionHandler方法返回一个非空的处理器，则调用它
				3.如果Throwable是ThreadDeath的一个实例，什么都不做
				4.线程的名字以及Throwable的栈踪迹被输出到System.err上

   同步：两个或两个以上的线程需要共享同一数据的存取，可能会产生错误。这个情况成为竞争条件。
	
   

   
   
   
   
Q：集合类（有序的意思是根据添加的顺序存放）
A：Collection接口是集合接口树的根。java提供了一个操作Set、List、Map等集合的工具类：Collections，
	该工具类里提供了大量方法对集合进行排序、查询、修改等操作，还提供了将集合对象设置为不可变、对集合对象实现同步控制等方法。

	Set接口无序不重复：
		HashSet是Set接口的典型实现，是最常用的Set实现类，当向其中存一个元素的时候，HashSet会调用该对象的hashCode()方法
		得到该对象的hashCode值（伪地址），然后根据hashCode值向相应的内存中存放元素。如果两个元素的equals相等而它们的hashCode值
		不同，则HashSet会将它们存放在不同的位置。如果它们的hashCode值相同，但是equals返回值不同，HashSet会在这个位置用链式结构
		保存多个元素（相当于Hash用链表防止冲突），这样会导致性能下降，所以一般在重写equals方法的时候，也应该重写hashCode方法。
		如果hashcode值相同，equals也返回true，则不能重复添加，只显示一个。
		
		LinkedHashSet原理实现和HashSet基本相同，不同的是它除了根据对象的hashCode值决定存放位置，
		还使用了链表来维护元素的次序，所以是有序存放的。
		
		TreeSet是SortedSet接口的实现类,它的数据结构采用的是红黑树，所以它可以对元素进行排序，但元素是不重复的。
		而且提供了comparator方法可以定制排序，当不使用comParator方法时，它是根据元素的compareTo方法来判断元素大小的，
		所以在使用TreeSet的时候，如果要重写equals方法，应该注意其compareTo方法也要重写；
		
		HashSet是最常用的，但是其具有不重复无序的特点，
		LinkedHashSet由于采用链式维护，所以其是有序的，但性能降低了；
		TreeSet由于需要额外的红黑树来维护集合元素的次序，所以其性能不好，但是如果集合元素需要排序可以考虑用TreeSet;
	
	List接口有序可重复：
		ArrayList与Vector作为List类的两个典型实现，基本功能是一样，只不是Vector出现的早点，ArrayList是后来出现在的，
		所以ArrayList的方法名可以短一些，两者实现的原理都是封装了一个动态的、允许再分配的Object[]数组，
		另外ArrayList是线程不安全的，Vector是线程安全的，所以通常尽量少用Vector.

		LinkedList也是List的实现类，它是一个基于链表实现的List类，对于迭代访问，插入、删除的速度非常快，
		但是如果如果根据索引拿取元素，它就不那么快了，这时应该用ArrayList；另外LinkedList还实现了Deque接口，
		因此它可以被当成双端队列来使用，自然也可以被当成“栈”来使用，因此现在的程序中需要使用“栈”这种数据结构时，
		推荐使用ArrayDeueue或LinedList，而不是Stack；
		
		一些操作：添加add() 移除remove(index) 得到get(index) 修改set(index,"") 元素数size() 打乱顺序Collections.shuffle(list)
		
	Map接口键值对形式：
		Map是用来保存具有映射关系的数据，是一个无序不可重复的集合，相当于“关联数组”；Set和Map的关系十分密切，
		java源码就是先实现了HashMap、TreeMap等集合，然后通过包装一个所有的value都为null的Map集合实现了Set集合类，
		所以呢在说Map的时候key值几乎和我们说的set一模一样，所以相似的我就不多提了
	
		Hashtable与HashMap，光看名字就知道Hashtable是一个很古老的实现类，因为他的名字都没有符合驼峰命名规范，
		而HashMap就是它的替代类，跟ArraySet和Vector一样，HashMap是线程不安全的而Hashtable是线程安全的，但不建议用Hashtable，
		如果需要同步可以用Collection工具类来进行包装。它们另个一个区别是HashMap里面的key和value值都可以为null，而Hashtable不可以

		LinkedHashMap和LinkedHashSet一样，是用了一个双链表来维护key-value队伍次序，所以它可以实现有序插入，但是性能必然降低了。
		
		TreeMap实现了SortedMap接口，当然功能也和TreeSet相似，可以自然排序也可以定制排序（排序的对象是Key值）
		

Q：关于输入输出流I/O
A：字节流byte可以处理所有类型的数据，如MP3、图片、文字、视频等。在读取时，读到一个字节就返回一个字节。对应的类都以“Stream”结尾。

   字符流char仅能够处理纯文本数据，如txt文本，在读取时，读到一个或多个字节，先查找指定的编码表，然后将查到的字符返回。
	   对应的类都以“Reader”或“Writer”结尾
  
   使用字节流读写文件：FileInputStream、FileOutputStream   
   
   使用带缓冲的字节流读写：字节流+BufferedInputStream、字节流+BufferedOutputStream

   使用字符流读写：字节流+InputStreamReader、字节流+OutputStreamWriter  
   
   使用带缓冲的字符流读写：字符流+BufferedReader、字符流+BufferedWriter

   文件读取类FileReader extends InputStreamReader
   文件输出类FileWriter extends OutputStreamWriter   已经是字符流了，只能处理纯文本数据
  








