Q:面向对象编程是什么，有什么优点，和面向过程有什么区别？
A:面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了，数据和对数据的操作是分开的。
面向对象是把某些事物分解成各个对象，将数据和方法封装在一个整体（类）里面，操作时只要调用对象的方法即可，不用关注具体过程。
优点：	1.代码开发模块化，更易维护和修改。2.代码复用。3.增强代码的可靠性和灵活性。4.增加代码的可理解性。
面向对象编程有四大重要的特性： 封装，继承，多态和抽象


Q：JDK、JRE、JVM？什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
A：Java虚拟机（JVm）是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。
虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。
Java虚拟机有自己完善的硬体架构，如 处理器 、 堆栈 、 寄存器 等，还具有相应的 指令 系统。
JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（ 字节码 ），
就可以在多种平台上不加修改地运行。

Java运行时环境(JRE)包含将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。
Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。


Q：什么是Java？
A：Java编程语言是个简单、完全面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的编程语言。

Q:Java标识符由哪些组成？首字符可以是什么？
A：标识符的组成：1.字母 2.数字 3.下划线“_” 4.美元符号$  首字母不能是数字、Java关键字不能做标识符如public,private,package
   所谓的字母是广义的，中文也可以，如“你好”可以作为标识符 
   Java有50个关键字，其中const和goto作为保留字,true、false、null不是严格意思上的Java关键字，main不是关键字

Q:基本数据类型之间的类型转换
A：布尔型boolean与其他基本数据类型不可互相转换。
   字符型char与字节型byte、短整型short之间可以进行强制类型转换，没有强弱之分
   byte < short < int < long < float < double

   byte是字节数据类型，是有符号型的，占1个字节(8个位)；大小范围为-128—127
   char是字符数据类型，是无符号型的，占2字节(Unicode码 ）；大小范围 是0—65535，JAVA用char来表示单个字符。
   如'u','+','中'需要用单引号括起来，将整数赋值，依据ASCII码转化，不能识别负数
   
   char、byte、int对于英文字符，可以依据ASCII码相互转化
   输出时，byte，int会都转换成整数，char转为字符

	Java表达式转型规则由低到高转换：
		1、所有的byte,short,char型的值将被提升为int型；
		2、如果有一个操作数是long型，计算结果是long型；
		3、如果有一个操作数是float型，计算结果是float型；
		4、如果有一个操作数是double型，计算结果是double型；
		5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。

Q:基本数据类型的默认值？
A:若基本数据类型作为类成员变量的时候，即使没有进行初始化。java也会给定默认的初始值。数值为0，布尔型为false
  但是在方法中声明一个变量，可能是任意值，会报错，不会初始化为默认值
   
Q:运算符
A:在取模运算%中，结果的符号与第一个操作数的符号相同， 11 % -5 = 1
  j=j++;运算顺序是先j增加1，然后把j原来的值赋给自己，所以j不变
  <、<=、>、=>只能用来比较基本数据类型（除了boolean），==、!=可以用在基本和引用数据类型上 

Q：==和equals()方法的区别？
A：1、值类型是存储在内存中的堆栈（简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。
　 2、==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。
　 3、equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同，左边不能用于基本数据类型，右边可以自动装箱
　 4、==比较的是2个对象的地址，而equals比较的是2个对象的内容，显然，当equals为true时，==不一定为true。
	总结：==比较的是栈中的内容是否相同，equals()方法比较的是堆中的内容是否相同，比较前先分清堆和栈中的内容是什么！
   ||（条件或）和 &&（条件与）具有 短路规则
   
Q：关于String字符串
A：String是不可变字符串，有一个优点：编译器可以让字符串共享。有一个字符串常量池。在编译期确定，存入.class文件
   通过String a = "abc";创建的都是字符串常量，在编译期内确定，只要内容相同，地址也相同。String b = "a" + "bc";也是字符串常量
		而 b+="abc" 或substring等操作不能在编译期确定，得到的结果不是字符串常量，地址不同。
   通过new String();创建的都不是字符串常量，不能在编译期确定.
   
   空串与Null串
   空串""是一个Java对象，有长度（0），有内容（空），判断 str.length()==0 或 str.equals("")
   Null串中放了一个特殊的值Null，表示目前没有任何对象与该变量关联，判断 str == null

Q:关于switch语句
A:对表达式计算，再与每个case子句中的常量值比较，匹配成功则执行该case子句后的语句，直到遇到break为止。
  要注意表达式必须是符合byte、char、short、int类型的表达式，不能使用浮点型或long类型或字符串（新版java支持字符串）

Q:Java支持哪三种跳转语句？
A:break、continue 和 return 
  break有三种作用 1.被用来终止switch 2.终止for、while循环 3.跳出带标号的语句块
  continue语句只结束本次循环，而break是结束整个循环语句的执行
  return语句的作用是终止当前方法的执行，返回到这个方法的调用者

Q:类的加载过程//TODO与对象的初始化
A:当程序执行时，需要生成某个类的对象，Java执行引擎会先检查是否加载了这个类，如果没有加载，则先执行类的加载再生成对象，
  在类的加载过程中，类的static成员变量会被初始化，如果类中有static语句块，则会执行static语句块。
	初始化static成员变量和执行static语句块的顺序同代码中的顺序一致。记住，在Java中，类是按需加载，只有当需要用到这个类的时候，
	才会加载这个类，并且只会加载一次。
  在生成对象的过程中，会先初始化对象的成员变量，然后再执行块，再执行构造器。
  父类加载-->子类加载-->父类初始化-->子类初始化
  类实例销毁时候，首先销毁子类部分，再销毁父类部分
  

Q：关于构造方法
A：修饰符可以有访问权限的修饰词（4种），不能有其他如abstract、final、native、static或synchronized
   方法名即类名，可以有任意个参数，没有返回类型也没有void
   默认有一个无参构造方法，但如果已经有了定义的构造方法，系统不会创建这个默认无参构造方法

Q：构造方法的继承性
A：构造方法是从顶向下进行调用的，子类的构造方法中必须要通过super关键字在第一行调用父类的构造方法，
	 如果调用的是父类无参构造方法，可省略super()，系统会自动加上
	 如果调用父类有参构造方法，必须显式调用super(...)，确保子类在初始化前父类会被实例化
     父类的构造器调用以及初始化过程一定在子类的前面。	
   
Q：关于main方法
A：修饰符public 因为main方法是JVM自动调用的，需要让JVM可见
   static：由于main是所有程序的入口，被调用时没有任何对象创建，要想不通过对象调用某一方法，只有将该方法定义为static方法
   void：JVM对于Java程序来说已经是系统的最底层，由它调用的方法的返回值无处可去
   String args[]：能够接收命令行传入的参数

Q：方法参数的传递
A：★java中的变量有两种类型：引用类型(对象)和基本数据类型。当他们被作为参数传递给方法时，他们都是传值的副本或者引用地址的副本！

Q: static关键字
A：类变量和类方法的调用，直接 类名.类变量  类名.类方法（【参数列表】）
   两条重要原则：1.类方法不能访问所属类的非静态变量和方法，只能访问方法体内的局部变量、参数和静态变量
	             2.类方法中不能出现this和super关键字
   static修饰的变量和方法能独立于任何对象，因此某一个对象修改了类变量的值，会导致所有对象中的类变量一起发生改变，
   因为所有的对象中的类变量仅仅存放的是一个引用值，该引用值都是指向类变量真正存放的静态存储区的内存地址
   如果要通过计算来初始化static变量，可以声明一个static语句块，仅在该类第一次被加载时执行
 
Q：“static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？
A：“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
Q：是否可以在static环境中访问非static变量？
static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。


Q：final关键字
A：final关键字可以用来修饰变量、方法和类。
   当final修饰基本数据类型时，该变量就成了常量，值无法改变
   当final修饰引用数据类型时，该变量的值不能改变，即储存的地址不变，不能再去指向别的对象，但对象内的成员可以改变
	用final修饰的类称为最终类，该类不能被继承，其中的方法自动成为final方法，不包括属性
	用final修饰的方法不能被子类覆盖
	用final修饰方法的参数，表示该方法不期望该参数传进来后有任何改变

Q：封装性
A：可见度：同一个类中、同一个包中、不同包的子类、不同包的非子类
   权  限:private、default、protected、public
   类能使用的访问修饰符只有default和public
   类成员能使用四种，其中default不能写出来
   方法中的变量不能有访问修饰符

Q:继承性
A:子类继承父类的成员变量，当子类继承了某个类之后，便可以使用父类中的成员变量，但是并不是完全继承父类的所有成员变量
　1）能够继承父类的public和protected成员变量；不能够继承父类的private成员变量；
　2）对于父类的default成员变量，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
　3）对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，
		即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。
		
　子类继承父类的方法，同样地，子类也并不是完全继承父类的所有方法。
　1）能够继承父类的public和protected成员方法；不能够继承父类的private成员方法；
　2）对于父类的default成员方法，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
　3）对于子类可以继承的父类成员方法，如果在子类中出现了同名称的成员方法，则称为覆盖，
		即子类的成员方法会覆盖掉父类的同名成员方法。如果要在子类中访问父类中同名成员方法，需要使用super关键字来进行引用。
		
　注意：隐藏和覆盖是不同的。隐藏是针对成员变量和静态方法的，而覆盖是针对普通方法的。
  覆盖只针对非静态方法（终态方法不能被继承，所以就不存在覆盖一说了），而隐藏是针对成员变量和静态方法的。
  这2者之间的区别是：覆盖受RTTI（Runtime type  identification）约束的，而隐藏却不受该约束。
  也就是说只有覆盖方法才会进行动态绑定，而隐藏是不会发生动态绑定的。除了static方法和final方法，其他所有的方法都是动态绑定

Q：封装，多态，继承，抽象的解释？
A：封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。好处:1.通过隐藏对象的属性来保护对象内部的状态。2.提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。3.禁止对象之间的不良交互提高模块化。
多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。
表现形式主要有两种：方法重载Overloading，又称静态多态性，同一类中允许多个同名方法，但要求参数个数不同或参数类型不同或参数顺序不同。
方法覆盖Overriding，又称动态多态性，子类对父类方法重新定义，但方法名、返回值和参数形态完全一样。
继承给对象提供了从父类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。
抽象是把想法从具体的实例中分离出来的步骤，这种抽象技术的主要目的是把类的行为和实现细节分离开。
抽象和封装的不同点。抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。

方法的覆盖（override）两同两小一大原则：
方法名相同，参数类型相同
子类返回类型小于等于父类方法返回类型，
子类抛出异常小于等于父类方法抛出异常，
子类访问权限大于等于父类方法访问权限。
  
Q：向上转型，强制类型转换
A：Father father = new Son(); 
			father是Father类的对象，变量是Father的，但方法是Son类的。在内存中本质还是Son类型的，
			只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！
      Son son = (Son)father;
			这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，
			将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。
			
	当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。
		Father father = new  Father();
		Son son = (Son) father;
		所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。		
		在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。
		
   子类可以向父类进行类型转型，使父类的的对象能引用子类的对象，父类的对象是通过实例化一个子类的对象而来的。
   向上转型后的对象是父类对象，没法调用子类的成员方法和成员变量，但如果存在同名的方法，也就是方法覆盖，父类的方法会被子类覆盖
   动态方法调度机制仅对方法有效，如果存在同名的变量，调用的还是父类的变量，可以通过调用被子类覆盖的方法访问子类的变量

   null可以被强制类型转换成任意类型，可以用来执行静态方法
   
Q：多态性，方法重载Overloading，方法覆盖Overriding
A：方法重载Overloading，又称静态多态性，方法名以及参数列表称为方法的签名，不同的方法，签名必须不同，方法重载要求方法名相同，
	那么参数列表不能相同，返回类型不是方法签名的一部分。
   方法覆盖Overriding，又称动态多态性，调用方式为动态绑定，子类对父类方法重新定义，但方法名、返回类型和参数列表要求一样。
   允许子类将覆盖方法的返回类型定义为原返回类型的子类型。子类方法不能缩小访问权限！	
   父类静态方法不能被覆盖！私有方法不能被覆盖！final修饰的方法不能被覆盖！这三种是静态绑定

   
Q：抽象类
A：抽象类是专门设计用来让子类继承的类，提供一个类的部分实现，其内部可以有成员变量、构造方法、具体方法和抽象方法。
   抽象方法以分号结束！abstract 返回类型 方法名（参数列表）;
   抽象类不会有实例，在JDK1.8可以有main方法，可以运行，可以有构造方法
   对于类，不能同时用final和abstract说明，
   1、抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。
   原因如下：抽象方法没有方法体，是用来被继承的，所以不能用private修饰；static修饰的方法可以通过类名来访问该方法（即该方法的方法体），
   抽象方法用static修饰没有意义；使用synchronized关键字是为该方法加一个锁。。而如果该关键字修饰的方法是static方法。
   则使用的锁就是class对象的锁。如果是修饰类方法。则用this变量锁。但是抽象类不能实例化对象，因为该方法不是在该抽象类中实现的。
   是在其子类实现的。所以。锁应该归其子类所有。所以。抽象方 法也就不能用synchronized关键字修饰了；
   native，这个东西本身就和abstract冲突，他们都是方法的声明，只是一个吧方法实现移交给子类，另一个是移交给本地操作系统。
   如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢？ 

   
Q：接口
A：接口不是类，而是对类的一组需求描述，由常量和抽象方法组成，
   [public] interface 接口名 [extends...]{
	数据类型 变量名 = 常量值；
	返回类型 方法名（参数列表）;
   }
   接口具有继承性，可以继承多个父接口，用逗号隔开，interface C extends A,B{...}
   默认接口中所有成员变量的修饰都是加上public、static、final
   默认接口中所有成员方法都是public、abstract，
   only public, abstract, default, static and strictfp are permitted，如果改成default或static就要添加方法体，不是抽象方法了
   only one of abstract, default, or static permitted
   接口本身具有抽象属性，加不加abstract都可以，访问控制权限只有public和default	   
   同一个Java源文件只能有一个public修饰的类或接口
   接口不含构造方法，不能直接通过接口生成接口
   实际测试jdk8：接口可以有main方法，可以运行，不能用new实例化
		 可以有静态方法，要有方法体，此时已不是抽象方法，可以在main里面直接调用运行
		 可以有default修饰的方法，必须有方法体，此时已不是抽象方法
   当一个类实现了一个接口，就必须实现其中所有的方法，就是方法覆盖，由于方法覆盖不能缩小父类方法的访问权限，
	而接口方法默认public，实现的方法也必须是public
   接口回调，interface A{} class B implements A{}  A a = new B();
	a被定义成接口A类型，被一个B实例赋值，只有接口定义声明的方法，
	那B的属性以及其他方法呢，如果它实现接口声明的方法中有其他属性和方法呢，实践证明都是可以在接口声明的方法里用

Q：接口和抽象类的区别是什么？
A：Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
类可以实现很多个接口，但是只能继承一个抽象类
类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
抽象类可以在不提供接口方法实现的情况下实现接口。
Java接口中声明的变量默认都是static final的，不过接口一般不定义变量。抽象类可以包含非final的变量。
Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。

	
Q：内部类
A：如果类B被定义在类A内，那么类B就是一个内部类，它为类A所知，不被类A的外界所知，类B可以访问类A的成员，包括private成员。
	内部类的类名只用于定义它的类或语句块中，在外部引用必须给出带外部类的完整名称。
	内部类的名字不允许与外部类的名字相同。
	内部类可以是抽象类或接口，若是接口，则可以由其他内部类实现。
    按照内部类是否有显示的类名来划分为  实名内部类和匿名内部类
	  实名内部类可以有四种访问控制方式，可以有static称为静态实名内部类，创建格式为：new 外部类名.实名内部类名（参数列表）
	      没有static的称为不具有静态属性的实名内部类，它的成员变量若有静态属性，则必须有final属性，但成员方法不能有静态属性，
		  创建格式：外部类实例对象.new 实名内部类名（参数列表）
	      访问静态属性的成员：外部类名.实名内部类名.静态成员
              访问不具有静态属性的成员：实名内部类实例对象.成员
      	  匿名内部类，不具有类名，且类不具有抽象和静态属性，也不能排生出子类，
		  定义格式：new 父类名（父类型的构造方法的参数列表）{...}
	      优点1.进一步实现多重继承，可以使用接口实现多重继承，但必须实现接口里所有方法，而通过内部类就没这个问题
		  2.能更好地解决接口和父类中方法的同名冲突，即通过一个内部类来实现接口，本类继承父类
		  3.隐藏程序实现的细节
		  4.能够无条件访问外部类的成员


Q：反射
A：主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。
	在java中，通过反射，能够在"运行态"动态获得任意一个类的所有属性和方法，动态地调用对象的方法。

	在程序运行期间，系统始终为所有的对象维护一个被称为运行时的类型标识，这个信息跟踪每个对象所属的类。
	可以通过专门的Java类访问这些信息，保存这些信息的类被称为Class，有三种方法获取Class
	1.对象的getClass()方法会返回一个Class类型的实例。
	2.类.class返回一个Class类型的实例。
	3.知道类的包名类名，可以通过Class的静态方法forName(String name)得到类名对应的Class对象，并且动态加载了这个类。
	

	可以用Class的newInstance()方法快速创建一个类的实例，调用的是无参构造方法，如果没有无参构造方法，则报错。
	getFields、getMethods、getConstructors方法分别返回类提供的public属性、方法和构造器数组，包括超类的公有成员
	要是其中加了Declare，如getDeclareFields方法，将返回类中声明的全部属性、方法和构造器，但不包括超类的成员

	检查类的结构：有三个类Field、Method、Constructor分别描述类的属性、方法和构造方法
	Modifier类可以分析修饰符，getModifiers()方法获得调用它的类或属性或方法的修饰符,用它的toString(int mod)方法将修饰符打印输出

	运行时查看属性的实际内容：class.getDeclareField(属性名).get(对象名)，不能看私有属性，要查看得加上Field.setAccessible(true)
	可以获得就可以设置，Field.set(对象名，值)

	调用方法：先得到指定方法名getMethod(String name,Class...parameterTypes)，调用invoke(Object obj,Object...args)
	method.invoke(对象名，参数s)，若是静态方法，则对象名为null


Q：多线程、多进程
A：一个程序同时执行多个任务，每个任务称为一个线程thread，区别，每个进程拥有自己的一整套变量，而线程则共享数据。
		
   在Java中创建线程有两种常用的方法：继承Thread类或实现Runnable接口。Thread类实际上也是实现了Runnable接口的类。
   Thread和Runnable的区别：如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。

   实现Runnable接口在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，
   然后调用Thread对象的start()方法来运行多线程代码。
   实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，
   最终还是通过Thread的对象的API来控制线程的，
   
Q：进程和线程的区别是什么？要有深度
A：//TODO

Q：线程的启动方式是start还是run？
A：start是启动线程，run是普通的调用run方法。
	 
Q：创建线程有几种不同的方式？你喜欢哪一种？为什么？
A：有三种方式可以用来创建线程：
		继承Thread类
		实现Runnable接口
		应用程序可以使用Executor框架来创建线程池

		实现Runnable接口比继承Thread类所具有的优势：
			1）：适合多个相同的程序代码的线程去处理同一个资源
			2）：可以避免java中的单继承的限制
			3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
		同时，线程池也是非常高效的，很容易实现和使用。

		main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。
		在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，
		实际上都会启动一个jvm，每一个jvm实现在就是在操作系统中启动了一个进程。
   
Q：线程的五种状态
A：1、新建状态（New）：新创建了一个线程对象。
	2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
	3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
	4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
		（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。
		（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
		（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
	5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

Q：Java等待/通知机制
A：都是Object的方法，必须在同步代码中使用（为了防止在进入wait过程中就调用了notify，导致一直阻塞，等待和通知这两个操作必须互斥）
	是指一个线程A调用了对象O的wait()方法释放了锁并进入等待阻塞状态，另一个线程B调用了对象O的notify()或者notifyAll()方法，
		线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。

	典型用法：分为等待方（消费者）和通知方（生产者）
		等待方遵循以下原则：1.获取对象O的锁
							2.循环判断条件是否满足，如果不满足，调用对象O的wait方法，会释放锁并进入等待阻塞，被通知后仍要检查条件。
							3.条件满足则执行对应的逻辑
		通知方遵循以下原则：1.获得对象O的锁
							2.改变条件，以满足等待方的需求
							3.通知一个或所有等待在对象O上的线程，在同步代码块执行完之后释放锁，被唤醒的线程将竞争对象O的锁
	
	
Q：线程调度
	线程优先级：每一个线程都有优先级，默认继承父线程的优先级，可通过setPriority方法设置。每当线程调度器有机会选择新线程时，
				它首先选择较高优先级的线程，但线程优先级高度依赖操作系统，要看宿主机平台的线程实现机制。
			   
	线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，
				就转为就绪（Runnable）状态。sleep()平台移植性好。
	
	线程让步：Thread.yield() 方法，将当前正在执行的线程对象转为可运行状态，把执行机会让给相同或者更高优先级的线程，很可能没用，
			因为当前线程对象有可能又被线程调度器选中运行。sleep()和yield()的区别
        
		sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；
		yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。
	
		sleep和wait的区别有：
			1，sleep是Thread类的静态方法，不涉及线程同步的概念；wait是Object的方法，实现等待/通知机制
			2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
			3，wait，notify和notifyAll只能在同步代码中（获得过锁）使用，而sleep可以在任何地方使用
				synchronized(x){
					x.notify()//或者x.wait()
				}
				
	线程加入：join()方法，等待调用者线程终止。在当前线程A中调用另一个线程B的b.join()方法，则线程A转入阻塞状态，
					直到线程B终止之后才从b.join()返回，线程A由阻塞转为就绪状态。另有超时特性，在给定的时间内线程B没有终止，也会从该方法返回。
					这里方法涉及了Java等待/通知机制。
			
	线程中断：interrupt()，这种结束方式比较粗暴，如果t线程打开了某个资源还没来得及关闭也就是run方法还没有执行完就强制结束线程，会导致资源无法关闭
　　		要想结束进程最好的办法就是用sleep()函数的例子程序里那样，在线程类里面用以个boolean型变量来控制run()方法什么时候结束，run()方法一结束，该线程也就结束了。
	
	守护线程：通过调用setDaemon(true)将线程转为守护线程。其唯一用途是为其他线程提供服务，例如计时线程。当只剩下守护线程时，虚拟机就立即退出，守护线程的finally块也不会执行。
			 
	处理未捕获异常的处理器：不被检测的异常会导致线程终止，在线程死亡之前，异常被传递到一个用于未捕获异常的处理器，
						   通过setUncaughtExceptionHandler方法来为线程安装一个处理器，默认为空。
						   
	线程组：如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。线程组是一个可以统一管理的线程集合。
		   ThreadGroup类实现了Thread.UncaughtExceptionHandler接口，按顺序选择下面一个操作：
				1.如果该线程组有父线程组，则调用父线程组的uncaughtException方法
				2.如果Thread.getDefaultExceptionHandler方法返回一个非空的处理器，则调用它
				3.如果Throwable是ThreadDeath的一个实例，什么都不做
				4.线程的名字以及Throwable的栈踪迹被输出到System.err上

   同步：两个或两个以上的线程需要共享同一数据的存取，可能会产生错误。这个情况成为竞争条件。

	main()函数即主函数，是一个前台线程，前台进程是程序中必须执行完成的，而后台线程则是java中所有前台结束后结束，不管有没有完成，后台线程主要用与内存分配等方面。                                                                                           
	前台线程和后台线程的区别和联系：
		1、后台线程不会阻止进程的终止。属于某个进程的所有前台线程都终止后，该进程就会被终止。所有剩余的后台线程都会停止且不会完成。
		2、可以在任何时候将前台线程修改为后台线程，方式是设置Thread.IsBackground 属性。
		3、不管是前台线程还是后台线程，如果线程内出现了异常，都会导致进程的终止。
		4、托管线程池中的线程都是后台线程，使用new Thread方式创建的线程默认都是前台线程。
	说明： 应用程序的主线程以及使用Thread构造的线程都默认为前台线程                       
		使用Thread建立的线程默认情况下是前台线程，在进程中，只要有一个前台线程未退出，进程就不会终止。
		主线程就是一个前台线程。而后台线程不管线程是否结束，只要所有的前台线程都退出（包括正常退出和异常退出）后，进程就会自动终止。
		一般后台线程用于处理时间较短的任务，如在一个Web服务器中可以利用后台线程来处理客户端发过来的请求信息。
		而前台线程一般用于处理需要长时间等待的任务，如在Web服务器中的监听客户端请求的程序，或是定时对某些系统资源进行扫描的程序
		
Q：锁的升级与对比
A：锁有4种状态，级别从低到高依次是无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。
		
		偏向锁：如果同一个线程经常要获得某个锁，为了让它获得锁的代价更低而引入偏向锁。偏向锁使用了一种等到竞争出现才释放锁的机制，
						当其他线程尝试竞争偏向锁时，持有偏向锁的线程才释放锁。
			原理：当一个线程访问同步代码块时并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，
						以后该线程在进入和退出同步代码块时不需要进行CAS操作来加锁和解锁。
			优点：加锁解锁不需要额外的消耗，和执行非同步方法相比差距很小。
			缺点：如果有线程来竞争锁，会带来额外的锁撤销的消耗。
			场景：适用于只有一个线程访问同步块
		
		轻量级锁：//TODO
			优点：竞争的线程不会阻塞
			缺点：如果始终竞争不到锁，线程会自旋消耗CPU
			场景：追求响应时间，同步代码块执行速度非常快
		
		重量级锁：synchronized
			优点：线程竞争不使用自旋，不会消耗CPU
			缺点：线程阻塞，响应时间缓慢
			场景：追求吞吐量，同步代码块执行慢
		
Q：synchronized关键字
A：我的理解
	 一、synchronized是重量级锁，可以用于创建代码块、修饰普通方法和静态方法
	 
	 二、创建代码块时需要指一个对象作为互斥体，如果是类的class实例，则锁的是该类的Class对象，相当于修饰所有静态方法。
				如果是一个对象，则锁的是该对象，相当于修饰所有普通方法
	 
	 三、一个类只有一个锁，一个对象也只有一个锁，它们互相不干扰
	 
	 四、当一个线程访问同步代码时，它首先必须得到锁，退出或抛出异常时必须释放锁。另一个线程再想访问该同步代码时会被阻塞，
				但是它可以访问非同步代码，当持有锁的线程释放锁之后会唤醒这个被阻塞的线程，对锁进行新的一轮竞争
				
	 五、本质是对一个对象的监视器monitor进行获取
	 
Q：volatile关键字
A：volatile是轻量级的synchronized，保证从主内存加载到线程工作内存的值是最新的
		用volatile修饰后的变量不允许有不同于主内存区域的变量拷贝。任何线程中改变了它的值必须同步刷新回共享内存，所有其他线程立即获取到了相同的值
		对于volatile修饰的变量，读取时JMM会把该线程对应的本地内存置为无效，然后从主内存读取。但是加载与修改变量的值和写入主内存等操作并不是原子性的，
			所以即使用了volatile修饰变量，仍存在并发的问题。

		关于jvm运行时内存分配：每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，
		首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，
		之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），
		自动把线程变量副本的值回写到对象在堆中变量。
		
Q：线程池技术
A：ThreadPoolExecutor类是线程池的核心，继承自AbstractExecutorService，其实现了ExecutorService接口，其继承了Executor顶层接口。
		先看其构造方法，有七个参数
			corePoolSize：核心池的大小，在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，
								   当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。
			maximumPoolSize：线程池最大线程数。
			keepAliveTime：表示线程没有任务执行时最多保持多久时间再终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，
			                      keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize
			unit：参数keepAliveTime的时间单位，有7种取值，是在TimeUnit类中的7种静态属性，从天一直到纳秒
			workQueue：阻塞队列，用来存储等待执行的任务。
			                     一般使用LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE
								      和synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。
								 较少使用ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小和PriorityBlockingQueue
			threadFactory：线程工厂，主要用来创建线程
			handler：表示当拒绝处理任务时的策略，有四种取值：
			                    ThreadPoolExecutor.AbortPolicy 丢弃任务并抛出RejectedExecutionException异常、
								ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
								ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
								ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务

		不过不推荐直接使用ThreadPoolExecutor，而是通过Executors的几个静态方法来创建线程池，如果它提供的不满足使用，可以自己创建

		在ThreadPoolExecutor类中有几个非常重要的方法：
			execute() 方法实际上是接口Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，
							这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。
	  　　submit() 方法是在接口ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，
							在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，
							但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，
							会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。
			shutdown() 此时线程池不能够接受新的任务，它会等待所有任务执行完毕
			shutdownNow() 线程池不能接受新的任务，并且会去尝试终止正在执行的任务
			
		重点是execute(Runnable)的执行步骤：
			   如果当前线程数小于核心线程池容量，则开启一个新线程并将该任务作为其第一个任务。
			   如果当前线程数不小于核心线程池容量，就将该任务放进等待队列中。
			   如果队列满了，则开启一个新的非核心线程处理它，此时总线程数不能超过设定的最大值。
			   如果开启非核心线程失败了，按照拒绝策略拒绝该任务。

Q：Callable、Future和FutureTask
A：创建线程的2种方式，一种是直接继承Thread，一种就是实现Runnable接口。这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。
      如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。
	  而自从Java 1.5开始，就提供了Callable和Future接口，通过它们可以在任务执行完毕之后得到任务执行结果。
	  
	  Callable是一个泛型接口，call()函数返回的类型就是传递进来的V类型。一般情况下是配合ExecutorService来使用的
	  
	  Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果，get()会阻塞直到任务返回结果。
	  FutureTask实现了Runnable和Future接口，它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。
			   
Q：死锁的四个必要条件和如何处理死锁
A：死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
            这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：
				互斥条件：一个资源每次只能被一个进程使用。
				请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
				不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
				循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

	避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。

Q：线程同步的方法，sychronized和lock的区别
A：//TODO
		
Q：集合类（有序的意思是根据添加的顺序存放）和数组
A：Collection接口是集合接口树的根。java提供了一个操作Set、List、Map等集合的工具类：Collections，
	该工具类里提供了大量方法对集合进行排序、查询、修改等操作，还提供了将集合对象设置为不可变、对集合对象实现同步控制等方法。

	Set接口无序不重复：
		HashSet是Set接口的典型实现，是最常用的Set实现类，当向其中存一个元素的时候，HashSet会调用该对象的hashCode()方法
		得到该对象的hashCode值（伪地址），然后根据hashCode值向相应的内存中存放元素。如果两个元素的equals相等而它们的hashCode值
		不同，则HashSet会将它们存放在不同的位置。如果它们的hashCode值相同，但是equals返回值不同，HashSet会在这个位置用链式结构
		保存多个元素（相当于Hash用链表防止冲突），这样会导致性能下降，所以一般在重写equals方法的时候，也应该重写hashCode方法。
		如果hashcode值相同，equals也返回true，则不能重复添加，只显示一个。
		
		LinkedHashSet原理实现和HashSet基本相同，不同的是它除了根据对象的hashCode值决定存放位置，
		还使用了链表来维护元素的次序，所以是有序存放的。
		
		TreeSet是SortedSet接口的实现类,它的数据结构采用的是红黑树，所以它可以对元素进行排序，但元素是不重复的。
		而且提供了comparator方法可以定制排序，当不使用comParator方法时，它是根据元素的compareTo方法来判断元素大小的，
		所以在使用TreeSet的时候，如果要重写equals方法，应该注意其compareTo方法也要重写；
		
		HashSet是最常用的，但是其具有不重复无序的特点，
		LinkedHashSet由于采用链式维护，所以其是有序的，但性能降低了；
		TreeSet由于需要额外的红黑树来维护集合元素的次序，所以其性能不好，但是如果集合元素需要排序可以考虑用TreeSet;
	
	List接口有序可重复：
		ArrayList与Vector作为List类的两个典型实现，基本功能是一样，只不是Vector出现的早点，ArrayList是后来出现在的，
		所以ArrayList的方法名可以短一些，两者实现的原理都是封装了一个动态的、允许再分配的Object[]数组，
		另外ArrayList是线程不安全的，Vector是线程安全的，效率很低，尽量少用。

		LinkedList也是List的实现类，它是一个基于链表实现的List类，对于迭代访问，插入、删除的速度非常快，
		但是如果如果根据索引拿取元素，它就不那么快了，这时应该用ArrayList；另外LinkedList还实现了Deque接口，
		因此它可以被当成双端队列来使用，自然也可以被当成“栈”来使用，因此现在的程序中需要使用“栈”这种数据结构时，
		推荐使用ArrayDeueue或LinkedList，而不是Stack；
		
		ArrayList是基于数组实现的，所以查询快，增删慢；LinkedList是基于链表实现的，所以查找慢，增删快。
		
		一些操作：添加add() 移除remove(index) 得到get(index) 修改set(index,"") 元素数size() 打乱顺序Collections.shuffle(list)
		
	Map接口键值对形式：
		Map是用来保存具有映射关系的数据，是一个无序不可重复的集合，相当于“关联数组”；Set和Map的关系十分密切，
		java源码就是先实现了HashMap、TreeMap等集合，然后通过包装一个所有的value都为null的Map集合实现了Set集合类，
		所以呢在说Map的时候key值几乎和我们说的set一模一样，所以相似的我就不多提了
	
		Hashtable与HashMap，光看名字就知道Hashtable是一个很古老的实现类，因为他的名字都没有符合驼峰命名规范，
		而HashMap就是它的替代类，跟ArraySet和Vector一样，HashMap是线程不安全的而Hashtable是线程安全的，但不建议用Hashtable，
		如果需要同步可以用Collection工具类来进行包装。它们另个一个区别是HashMap里面的key和value值都可以为null，而Hashtable不可以

		LinkedHashMap和LinkedHashSet一样，是用了一个双链表来维护key-value队伍次序，所以它可以实现有序插入，但是性能必然降低了。
		
		TreeMap实现了SortedMap接口，当然功能也和TreeSet相似，可以自然排序也可以定制排序（排序的对象是Key值）

	集合中线程安全的类有：vector，hashtable , stack，enumeration，除此之外均是非线程安全的类与接口
	
Q：Java集合类框架的基本接口有哪些？
Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：
Collection：代表一组对象，每一个对象都是它的子元素。
Set：不包含重复元素的Collection。
List：有顺序的collection，并且可以包含重复元素。
Map：可以把键(key)映射到值(value)的对象，键不能重复。


Q：什么是迭代器(Iterator)？
Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的
迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。


Q：Iterator和ListIterator的区别是什么？
下面列出了他们的区别：
Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

Q：HashMap的底层源码，原理？如何实现一个HashMap？自定义类型可以作为Key吗？扩容因子过大过小的缺点，扩容过程
A：//TODO

Q：HashMap和Hashtable有什么区别？
HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：
HashMap允许键和值是null，而Hashtable不允许键或者值是null。
Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。
一般认为Hashtable是一个遗留的类。


Q：数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？
下面列出了Array和ArrayList的不同点：
Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
Array大小是固定的，ArrayList的大小是动态变化的。
ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。


Q：ArrayList和LinkedList有什么区别？
ArrayList和LinkedList都实现了List接口，他们有以下的不同点：
ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。
相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。
LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。

ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，
如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，
然后，把之前的数据拷贝到新建的数组。

对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
ArrayList是数组，所以，直接定位到相应位置取元素，LinkedLIst是链表，所以需要从前往后遍历。

ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。
正确，因为ArrayList空间的增长率为1.5倍，所以，最后很可能留下一部分空间是没有用到的，因此，会造成浪费的情况。对于LInkedList的话，
由于每个节点都需要额外的指针

Q：HashSet和TreeSet有什么区别？
HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。
另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。


Q：如何权衡是使用无序的数组还是有序的数组？
有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。


Q：Java集合类框架的最佳实践有哪些？
根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。
有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。
为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。
使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。
编程的时候接口优于实现。
底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。

Q：关于泛型
A：1.虚拟机中没有泛型，只有普通类和普通方法
	 2.所有泛型类的类型参数在编译时都会被擦除
	 3.虽然有泛型的类型擦除机制，但也能在运行时动态获取List<T>中T的实际类型，通过反射

Q：关于输入输出流I/O
A：流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，
     根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 

	  抽象类InputStream和OutputStream构成了输入/输出类层次结构的基础。
	  （字节流不便处理Unicode编码的信息，因为其每个字符用了多个字节来表示。所以有单独的类层次结构处理它，都是基于两字节的。）
	  
	  抽象方法read()和write()是最基础的，读写一个字节，在执行时都将阻塞，直至字节确实被读入或者写出。
	  
	  完成对流的读写时应该调用close()来关闭，释放系统资源。关闭输出流的同时还会冲刷其缓冲区，也可用flush()来手动冲刷。
   
	字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 
	字节流Byte和字符流Char的区别：
		读写单位不同：字节流以字节（1Byte = 8bit）为单位，字符流以字符为单位，一次可能读多个字节，根据指定的编码表映射字符。
		处理对象不同：字节流能处理所有类型的数据（如图片、avi、MP3等），而字符流只能处理字符类型的数据。
	结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。
  
	读取时的字节数组或字符数组的长度如何确定？
  
	缓冲区的作用：
	用了BufferedInputStream后你每次读取都是从缓冲区里拷贝数据，缓冲区没东西了就调IO从数据源读到缓冲区，然后你再从缓冲区读。
	为什么会这样呢，因为你自己建立的数组大小和缓冲区大小一样，根本就没起到缓冲作用。
	当你程序的数组小于缓冲区的时候才会起到缓冲作用。
	比如是byte[] b=new byte[2048];，你要读的数据是1M，那么你要调512次IO，假设一次1s，就512s，
	但如果用BufferedInputStream，你每从缓冲区读取4（8192/2048=4）次才调用一次IO（假设访问内存一次0.1s），总共要128次，就128s，
	加上总的从缓冲区拷贝数据的时间（512*0.1=51.2s），128+51.2=179.2。这里用0.1s和1s来体现IO很耗时
  
    使用字节流读写：InputStream、OutputStream   （都是抽象类）
   
    使用带缓冲的字节流读写：字节流+BufferedInputStream、字节流+BufferedOutputStream

    使用字符流读写：字节流+InputStreamReader、字节流+OutputStreamWriter  
   
    使用带缓冲的字符流读写：字符流+BufferedReader、字符流+BufferedWriter

	基于磁盘操作的I/O：File
		文件读取类FileReader extends InputStreamReader
		文件输出类FileWriter extends OutputStreamWriter   
			已经是字符流了，只能处理纯文本数据，但并没有实现父类中带字符集参数的构造函数，所以仅能按系统默认的字符集编解码。所以不推荐，还是用父类好。
		    PrintWriter和其他Writer的区别：其他Writer没有相关的格式化的方法，而PrintWriter可以在写入同时对写入的数据进行格式化。
		
	基于网络操作的I/O：socket

Q：对象序列化
A：可以将任何对象写出到流中，也可以从流中读回。可以将对象保存到磁盘中，或者通过网络传输。
     每个对象都有一个序列号，用以代替原生的内存地址。


Q：JDBC连接数据库的步骤：
	加载驱动程序 Class.forName("com.ibm.db2.jcc.DB2Driver");
	与数据库建立连接 Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/jsp_db","admin","admin");
	执行查询，发送SQL语句 Statement stmt = con.creatStatement();
	获取结果集 ResultSet rs = stmt.executeQuery("SELECT * FROM user");
		   while(rs.next()){
			String s = rs.getString("name");
		   }
	关闭连接，清理环境
	
Q：PreparedStatement和Statement的区别
	1>PreparedStatement 接口继承 Statement
		PreparedStatement用于处理动态SQL语句，在执行前会有一个预编译过程，这个过程是有时间开销的，虽然相对数据库的操作，
		该时间开销可以忽略不计，但是PreparedStatement的预编译结果会被缓存，下次执行相同的预编译语句时，就不需要编译，
		只要将参数直接传入编译过的语句执行代码中就会得到执行，所以，对于批量处理可以大大提高效率。
	2>Statement每次都会执行SQL语句，相关数据库都要执行SQL语句的编译。
	3>作为开发者，应该尽可能以PreparedStatement代替Statement，提高了性能，提高安全性，防止sql注入
	
	Statement sta=con.createStatement();   ResultSet rst=sta.executeQuery(“select * from book where id = 1”);
	
	PreparedStatement pst=con.prepareStatement(“select * from book where id = ?”);
	pst.setParameter('1');
	ResultSet rst=pst.executeQuery();


Q:关于异常Exception
异常对象都是派生于Throwable类的一个实例。在下一层分成两个分支：Error和Exception。Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误，很少出现，一般不需要程序员处理。
需要关注的是Exception层次结构，又分解为两个分支：由程序错误导致的异常RuntimeException（错误的类型转换、数组越界、访问空指针等）
和程序没有问题但由于I/O错误这类问题导致的其他异常（在文件尾部后面读取数据、打开不存在的文件、根据给定的字符串查找不存在的Class对象）。
出现RuntimeException（不要关注这个名字）就一定是程序员的问题，应通过检测避免发生这类异常。
将派生于Error类或RuntimeException类的所有异常称为未检查异常，其他的称为已检查异常。编译器要求为所有已检查异常提供异常处理器。
也就是说除了不可控制的Error，程序员要避免发生RuntimeException的未检查异常，为其他的已检查异常提供异常处理器。
方法应该在其首部声明所有可能抛出的已检查异常（或者捕获）。例如public FileInputStream(String name) throws FileNotFoundException。
声明抛出的异常如果是某个特定类的实例时，可能抛出一个这个类的异常或者这个类的任意一个子类的异常。例如声明抛出IOException异常，既可能是IOException异常，
也可能是其子类异常例如FileNotFoundException。
抛出异常异常类：1.找到一个合适的异常类。2.创建这个类的一个对象。3.将对象抛出throw。一旦抛出，这个方法就不可能返回到调用者。
使用try...catch捕获异常并进行处理。通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常使用throws抛出，传递给它的调用者。

Q：throw和throws有什么区别？
throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。

Q：异常处理的时候，finally代码块的重要性是什么？
无论是否抛出异常，finally代码块总是会被执行。就算是没有catch语句同时又抛出异常的情况下，finally代码块仍然会被执行。最后要说的是，finally代码块主要用来释放资源，比如：I/O缓冲区，数据库连接。

Q：try...catch...finally与return
1、不管有没有有出现异常，finally块中代码都会执行；
2、当try和catch中有return时，finally仍然会执行；
3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存在临时变量，不管finally中的代码怎么样，
	返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
4、finally中最好不要包含return，否则程序会提前退出，会把try或者catch中的return覆盖掉。

Q：异常处理完成以后，Exception对象会发生什么变化？
Exception对象会在下一个垃圾回收过程中被回收掉。

Q：finally代码块和finalize()方法有什么区别？
无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。

Q：中间件
A：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/服务器的操作系统之上，
管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件相连接的系统，即使它们具有不同的接口，
但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。 
  （简单来说，中间件并不能提高内核的效率，一般只是负责网络信息的分发处理）
  
  
  
Q：Java内存模型
A：JMM是共享内存模型，线程之间的通信是隐式的。
		所有变量（实例域、静态域和数组元素但不包括局部变量、方法参数和异常处理器参数，后者是线程私有的）存储在主内存中，每个线程都有
		一个私有的工作内存，工作内存中保存了该线程使用到的变量，是主内存的副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中
		进行，而不能直接操作主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成
		
		本地内存是JMM的一个抽象概念，并不真实存在。
		JMM属于语言级的内存模型。
		
	线程A要和线程B通信的话，有两个步骤，先把线程A的本地内存A中更新过的共享变量刷新到主内存中去，然后线程B到主内存中读取这个共享变量到本地内存B中。
	
	内存间交互操作
	　　关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，
	    Java内存模型定义了以下八种操作来完成：

			lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
			unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
			read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
			load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
			use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
			assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
			store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
			write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。
			　　
		如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，
			就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，
			store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。
			Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

			不允许read和load、store和write操作之一单独出现
			不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
			不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
			一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
			一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
			如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
			如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
			对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。
	
Q：GC算法
A：//TODO

Q：JVM解释编译执行过程
A：//TODO

Q：了解哪些设计模式，口述如何实现单例模式
A：//TODO

Q：java1.8的新特性
A：//TODO

Q：java数据结构
A：//TODO

Q：判断单链表有没有环
A：//TODO

Q：排序算法，重点问了快排，快排的优化
A：//TODO

Q：操作系统同步方式、通信方式
A：//TODO

Q：计算机网络三次握手四次分手以及wait_time三种差别
A：//TODO

Q：Http post和get差别
A：//TODO

Q：http状态码
A：//TODO





