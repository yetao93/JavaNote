Spring所有的事务管理策略类都继承自org.springframework.transaction.PlatformTransactionManager接口

Spring事务回滚规则： 
		默认配置下，Spring只有在抛出的异常为unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。
		可以通过rollbackFor和noRollbackFor自定义是否回滚事务。如果在事务中将未检查异常捕获了，就不会回滚。

@Transactional用法：
		可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。
		Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。
		只能被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在private、default、 protected方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。
		默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。
			是因为spring采用动态代理机制来实现事务控制，而动态代理最终都是要调用原始对象的，而原始对象在去调用方法时，是不会再触发代理了！
		@Transactional对从父类继承来的public方法不起作用，会报错Could not obtain transaction-synchronized Session for current thread

事务只读属性 readyOnly
      只读事务用于客户代码只读但不修改数据的情形，只读事务用于特定情景下的优化，比如使用Hibernate的时候。默认为读写事务。
	  只读事务并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务
		     进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。 但是你非要在“只读事务”里面修改数据，也并非不可以，
			 只不过对于数据一致性的保护不像“读写事务”那样保险而已。 因此，“只读事务”仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可

事务传播行为 propagation：所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。
			REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。
			REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。
			SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
			NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
			NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。
			MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
			NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于REQUIRED。

事务隔离级别 isolation：隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：
			DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是READ_COMMITTED。Mysql的默认隔离级别是Repeatable read。
			READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。
			READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。
			REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。
			SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
				但是这将严重影响程序的性能。通常情况下也不会用到该级别。

在事务的并发操作中可能出现三种问题，脏读、不可重复读、幻读
	READ_UNCOMMITTED：读未提交，一个事务可以读取另一个未提交事务的数据，非常不安全
	
	脏读：在一个事务处理过程里读取了另一个未提交的事务中的数据。
	
	READ_COMMITTED：读已提交，就是一个事务要等另一个事务提交后才能读取数据。可以解决脏读。
	
	不可重复读：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新了原有的数据。
	
	REPEATABLE_READ：可重复读，就是在开启一个事务后，不再允许其他事务的修改操作。可以解决不可重复读。注意是不允许修改，新增还是可以的。
	
	幻读：在一个事务的两次查询中数据笔数不一致，事务A读取某一范围的数据时，事务B又在该范围内插入了新行。
	
	SERIALIZABLE：序列化，所有事务串行化顺序执行，可避免脏读、不可重复读、幻读。
	
		幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，
		而幻读针对的是一批数据整体（比如数据的个数）。

查看当前会话隔离级别   SELECT @@tx_isolation;
设置当前会话隔离级别	 set session transaction isolation level repeatable read;
查看系统当前隔离级别	 select @@global.tx_isolation;
设置系统当前隔离级别	 set global transaction isolation level repeatable read;

重点介绍一下mysql的MVCC
// TODO
