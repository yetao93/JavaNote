新建一个springMVC项目：
1.添加maven依赖
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-webmvc</artifactId>
		<version>4.3.2.RELEASE</version>
	</dependency>
	
	
2.DispatcherServlet是前置控制器，配置在web.xml文件中的。拦截匹配的请求，把拦截下来的请求，依据相应的规则分发到目标Controller来处理

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
	http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1">
	<display-name>Archetype Created Web Application</display-name>
	<servlet>
		<servlet-name>springmvc</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<!-- 默认加载/WEB-INF/spingmvc-servlet.xml -->
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>classpath:springmvc-servlet.xml</param-value>
		</init-param>
		<!-- 加这个在tomcat启动时初始化Springframework，不加则在第一次收到请求时初始化 -->
		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>springmvc</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>
</web-app>

	
	
3.在src下添加springmvc-servlet.xml配置文件

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
    	http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context-4.1.xsd
        http://www.springframework.org/schema/mvc 
        http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd">                    
 
    <!-- scan the package and the sub package -->
    <context:component-scan base-package="test.SpringMVC"/>
 
    <!-- don't handle the static resource -->
    <mvc:default-servlet-handler />
 
    <!-- if you use annotation you must configure following setting -->
    <mvc:annotation-driven />
     
    <!-- configure the InternalResourceViewResolver -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
            id="internalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/jsp/" />
        <property name="suffix" value=".jsp" />
    </bean>
</beans>
	
	
4.1 在WEB-INF文件夹下创建名为jsp的文件夹，用来存放jsp视图。创建一个jsp。
4.2 建立包test.SpringMVC及Controller类，添加注解

	
关于一些常用注解：
handler method 参数绑定常用的注解,我们根据处理的Request的不同内容部分分为四类：（主要讲解常用类型）

A、处理request uri 部分（这里指uri template中variable，不含queryString部分）的注解：   
	@PathVariable,注解这样写@RequestMapping("/toUrl/{petId}")，在方法的参数前加@PathVariable，名称一致，
			      如不一致，用@PathVariable('petId')

B、处理request header部分的注解：
	@RequestHeader,处理请求头部分，@RequestHeader("Accept-Encoding")，可将Accept-Encoding的值赋给参数
	
	@CookieValue,可以把请求头中关于cookie的值绑定到方法的参数上。
				 如有JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84，可用@CookieValue("JSESSIONID")

C、处理request body部分的注解：
	@RequestParam,后面可以加name属性,指定参数传来的名称，必须一致，不指定就使用变量名。
			      可以加required属性,默认为true，必须传这个参数，否则报错，可以传null，也可以设置为false，不传即为null
				  还可以加defaultValue属性，指定默认值
				  
	最好使用name属性指定绑定的参数名，以避免因编译方式不同造成参数绑定失败，默认情况下java反射对象并未包含方法入参的名称
				  
	@RequestBody,该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，
				 然后把相应的数据绑定到要返回的对象上 ,再把HttpMessageConverter返回的对象数据绑定到controller中方法的参数上，
				 
D、处理attribute类型注解： @SessionAttributes, @ModelAttribute;


	@RequestMapping除了可以指定url和请求方法外，还可以指定请求头参数，请求参数
		@RequestMapping(value="/delete",method=RequestMethod.POST,params='userId',headers='content-type=text/*')
		如果没有指定请求方法，那么对所有方法都有效
	
	@ResponseBody 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，如使用json包
		写入到Response对象的body数据区，不用@ResponseBody则返回的字符串是视图名
	
导入json包后，可用@ResponseBody注解后返回map、list、object等类型数据，可用@RequestBody接收application/json类型数据
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.8.1</version>
		</dependency>	
	没有json包会报错 No converter found for return value of type: Object、Map、List	

		
	
关于 HttpMessageConverter 请求、响应信息转换器，具体还是不懂

	当控制器处理方法使用到@RequestBody或@ResponseBody时，才使用HttpMessageConverter对消息进行处理。
	spring先根据请求头的Content-Type或响应头的Accept属性选择匹配的Converter，进而根据参数类型的过滤得到匹配的Converter，
	如果找不到则报错。

	DispatcherServlet默认已经安装了AnnotationMethodHandlerAdapter作为HandlerAdapter的组件实现类。

	AnnotationMethodHHandlerAdapter默认已经装配了：
		StringHttpMessageConverter	
			将请求信息转换为字符串，可读取所有媒体类型的请求信息
			响应信息的媒体类型为text/plain即Content-Type的值
		
		ByteArrayHttpMessageConverter
			读写二进制数据byte[]，可读取所有媒体类型
			响应信息的媒体类型为application/octet-stream
		
		SourceHttpMessageConverter
			读取javax.xml.transform.Source类型，text/xml和application/xml媒体类型
			响应text/xml和application/xml
		
		XmlAwareFormHttpMessageConverter 
			将表单数据读取到MultiValueMap，支持application/x-www-form-urlencoded的媒体类型，也可xml，不支持multipart/form-data的媒体
			可写application/x-www-form-urlencoded和multipart/form-data
	另外：
		MappingJackson2HttpMessageConverter
			处理json格式化的请求和响应application/json 和 application/*+json with UTF-8 character set
			要加com.fasterxml.jackson.core包

	
	

	