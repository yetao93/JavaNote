# Redis

直接以问答的方式来吧。

## Redis 有哪些类型

Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。

键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。


| 类型   | 可以存的值             | 操作                                                                                              |
| ------ | ---------------------- | ------------------------------------------------------------------------------------------------- |
| STRING | 字符串、整数、浮点数   | 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作                     |
| LIST   | 列表                   | 从两端压入或者弹出元素 ；对单个或者多个元素进行修剪；只保留一个范围内的元素                       |
| HASH   | 包含键值对的无序散列表 | 添加、获取、移除单个键值对；获取所有键值对；检查某个键是否存在                                      |
| SET    | 无序集合               | 添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素 |
| ZSET   | 有序集合（比无序集合多个分值）               | 添加、获取、删除元素；根据分值范围或者成员来获取元素；计算一个键的排名                              |


## Redis 内部结构

## 淘汰策略

可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。

| 策略            | 描述                                                 |
| --------------- | ---------------------------------------------------- |
| volatile-lru    | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
| volatile-ttl    | 从已设置过期时间的数据集中挑选将要过期的数据淘汰     |
| volatile-random | 从已设置过期时间的数据集中任意选择数据淘汰           |
| allkeys-lru     | 从所有数据集中挑选最近最少使用的数据淘汰             |
| allkeys-random  | 从所有数据集中任意选择数据进行淘汰                   |
| noeviction      | 不淘汰，添加数据报错                                         |

作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。

使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。

Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。


## Redis 使用场景

### 计数器

可以对 String 进行自增自减运算，从而实现计数器功能。

Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

### 缓存

将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

### 查找表

例如 DNS 记录就很适合使用 Redis 进行存储。

查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

### 消息队列

List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息

不过最好使用 Kafka、RabbitMQ 等消息中间件。

### 会话缓存

分布式会话，可以使用 Redis 来统一存储多台应用服务器的会话信息。

当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。

### 分布式锁

在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。

可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

### 其他

Set 可以实现交集、并集等操作，从而实现**共同好友**等功能。

ZSet 可以实现有序性操作，从而实现**排行榜**等功能。

## Redis 持久化机制

Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。

### RDB 持久化

将某个时间点的所有数据都存放到硬盘上。

可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。

如果系统发生故障，将会丢失最后一次创建快照之后的数据。

如果数据量很大，保存快照的时间会很长。

TODO

### AOF 持久化

将写命令添加到 AOF 文件（Append Only File）的末尾。

使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：

- always，每个写命令都同步，会严重降低服务器都性能
- everysec，每秒同步一次，比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
- no，让操作系统来决定何时同步，并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。

随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。TODO

## Redis 事务

一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。

Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。

## Redis 主从、哨兵、集群

### 主从复制 Replication

通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失（或少量损失）数据，因为持久化会把内存中数据保存到硬盘上，重启会从硬盘上加载数据。
但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。
为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。
为此， Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。

在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库（slave）。
主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。
而从数据库一般是只读的，并接受主数据库同步过来的数据。
一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。

#### 复制原理

当从数据库启动时，会向主数据库发送sync命令，主数据库接收到sync后开始在后台保存快照rdb，在保存快照期间收到的命令缓存起来，当快照完成时，主数据库会将快照和缓存的命令一块发送给从数据库。初始复制结束。之后，主每收到1个命令就发送给从。

当出现断开重连后，会将断线期间的命令传给重数据库。即增量复制。

主从复制是乐观复制，当客户端发送写执行给主，主执行完立即将结果返回客户端，并异步的把命令发送给从，从而不影响性能。

#### 主从链

随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。

![redis-master-salve-chain](https://raw.githubusercontent.com/yetao93/JavaNote/master/md_pic/redis-master-salve-chain.png "redis-master-salve-chain")

#### 主从复制的缺点

- 不具备自动容错和恢复功能，主或从宕机后无法自动恢复或切换，需要手动操作。
- 主机宕机，宕机前有部分数据未能及时同步到从机，造成数据丢失。
- Redis的主从复制采用全量复制，在 Master 接收到sync后，fork出子进程做快照时，对机器会产生较大压力。
- 较难支持在线扩容。

### 哨兵

当主数据库遇到异常中断服务后，开发者可以通过手动的方式选择一个从数据库来升格为主数据库，以使得系统能够继续提供服务。
然而整个过程相对麻烦且需要人工介入，难以实现自动化。 为此，Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。
哨兵的作用就是监控redis主、从数据库是否正常运行，主出现故障自动将从数据库转换为主数据库。

它的功能包括以下两个。

1. 监控主数据库和从数据库是否正常运行。
2. 主数据库出现故障时自动将从数据库转换为主数据库。

#### 哨兵工作方式

1. 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。
2. 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）
3. 如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态
4. 当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）
5. 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。
6. 当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。
7. 若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。

主从切换过程：

1. slave leader升级为master
2. 其他slave修改为新master的slave
3. 客户端修改连接
4. 老的master如果重启成功，变为新master的slave

#### 哨兵模式的优缺点

优点:

- 哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。
- 主从可以切换，故障可以转移，系统可用性更好。
- 哨兵模式是主从模式的升级，系统更健壮，可用性更高。

缺点:

- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。
- 配置复杂

### 集群 cluster

即使使用哨兵，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据，浪费内存且有木桶效应。为了最大化利用内存，可以采用集群，就是分布式存储。

集群至少需要3主3从。每台redis存储不同的内容，分为16384个slot，每个redis实例分得一些slot，根据CRC16算法来取模得到所属的slot。
Redis 集群会把数据存在 master 节点，然后在这个 master 和其对应的 salve 之间进行数据同步。当读取数据时，也根据算法到对应的 master 节点获取数据。
只有当 master 挂掉之后，才会启动其对应的 salve 节点，充当 master 。存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。
PS，CRC16算法是什么？

Redis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，
每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点（包括主从）的连接，而且这些连接保持活跃，
这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。

![redis-cluster](https://raw.githubusercontent.com/yetao93/JavaNote/master/md_pic/redis-cluster.jpg "redis-cluster")

每一个节点都存有这个集群所有主节点以及从节点的信息。它们之间通过互相的ping-pong判断是否节点可以连接上。
如果有一半以上的Master节点去ping一个Master节点的时候没有回应，集群就认为这个Master节点宕机了，然后去连接它的Slave节点。
如果某个主节点和所有从节点全部挂掉，我们集群就进入fail状态。还有就是如果有一半以上的主节点宕机，那么我们集群同样进入fail状态。
这就是redis的投票机制。

## Redis 为什么快，为什么是单线程的

1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。
2. 数据结构简单，对数据操作也简单。
3. 采用单线程，避免了不必要对上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。
4. 使用I/O多路复用，非阻塞IO
5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求

弊端：无法发挥多核CPU的优势

## Redis、Memcache、MongoDB的区别

都是NoSQL数据库。
Redis、Memcache 比较相似，但与 MongoDB 完全不同，几乎没有可比性。
Redis/Memcache 是基于内存的，讲究的是性能，多用作缓存层。
MongoDB 是面向文档的，存储的是类似json的半结构化数据，查询方便，比较像关系型数据库。

数据结构
M：仅支持字符串类型。value最大只支持1MB
R：支持string、list、set、zset、hash等。value最大支持512MB

存储方式
M：把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小 。通过LRU算法抛弃最少使用的数据。
R：有部分存在硬盘上，支持数据的持久化！突破物理内存的限制。所有的key都在内存中，部分value会交换到磁盘。

底层模型
M：默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。但使得内存的利用率不高。
R：自己构建了VM机制，不调用系统函数

分布式
M：不支持分布式，只能在客户端中实现，通过一致性哈希之类的算法指定目标数据的节点
R：Redis Cluster 实现了分布式

性能
M：多核，存储100K以上大数据性能较好。
R：单核，存储小数据性能较好。可以在服务端直接对数据操作，减少网络IO。

应用场景
M：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况。
R：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统。


## 缓存穿透、缓存击穿、缓存雪崩

### 缓存穿透

查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致每次查询不存在的数据都会访问数据库。	
解决方案：
1. 缓存空值。若查询返回的数据为空，直接缓存一个默认值（比如null），下次查询就有值了。注意，过期时间设置的要较短。
2. 布隆过滤器。是一个很长的二进制向量和一系列随机映射函数。可以检索一个元素是否在一个集合中。优点是空间效率和查询时间都快，缺点是有一定的误识别率和删除困难。

### 缓存击穿

某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库
解决方案：
1. 热点数据缓存永不过期。将过期时间设置在value中。
2. 加互斥锁，去查数据库时需要先获得互斥锁，查询后设置缓存。要能根据key来加锁，获取A数据不影响其他线程获取B数据。


### 缓存雪崩

缓存服务器挂掉，或者热点缓存失效，所有查询落在了数据库，造成了缓存雪崩。与缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，从而查数据库，对数据库造成巨大压力，可能也会挂掉。
	解决方案：
		事前，redis高可用、主从+哨兵、redis cluster、避免全盘崩溃。
		事中，本地ehcache缓存、hystrix对数据库限流，服务降级、避免mysql崩溃。
		事后，redis持久化，重启redis，从磁盘加载数据，恢复缓存。

## 缓存一致性

最常见的缓存模型：
		读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
		更新的时候，先更新数据库，然后再删除缓存。

为什么是删除缓存，而不是更新缓存？
		在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。可能需要计算。
		延迟加载的思想，只有在使用到的时候才加载缓存。
		
先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致，怎么办？
		先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。
		因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。
		
数据即将发生变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了旧数据，放到了缓存中。随后数据完成变更，这时缓存是旧的，数据库是新的。
		做数据的唯一标识，TODO
