# Redis

直接以问答的方式来吧。

## Redis 有哪些类型


## Redis 内部结构

## Redis 使用场景

## Redis 持久化机制

## Redis 如何实现持久化

## Redis 主从、哨兵、集群

### 主从复制 Replication

通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失（或少量损失）数据，因为持久化会把内存中数据保存到硬盘上，重启会从硬盘上加载数据。
但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。
为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。
为此， Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。

在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库（slave）。
主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。
而从数据库一般是只读的，并接受主数据库同步过来的数据。
一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。

#### 复制原理

当从数据库启动时，会向主数据库发送sync命令，主数据库接收到sync后开始在后台保存快照rdb，在保存快照期间受到的命令缓存起来，当快照完成时，主数据库会将快照和缓存的命令一块发送给从数据库。初始复制结束。之后，主每受到1个命令就发送给从。

当出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库。即增量复制。

主从复制是乐观复制，当客户端发送写执行给主，主执行完立即将结果返回客户端，并异步的把命令发送给从，从而不影响性能。也可以设置至少同步给多少个从后，主才可返回给客户端。

#### 主从复制的缺点

- 不具备自动容错和恢复功能，主或从宕机后无法自动恢复或切换，需要手动操作。
- 主机宕机，宕机前有部分数据未能及时同步到从机，造成数据丢失。
- Redis的主从复制采用全量复制，在 Master 接收到sync后，fork出子进程做快照时，对机器会产生较大压力。
- 较难支持在线扩容。

### 哨兵

当主数据库遇到异常中断服务后，开发者可以通过手动的方式选择一个从数据库来升格为主数据库，以使得系统能够继续提供服务。
然而整个过程相对麻烦且需要人工介入，难以实现自动化。 为此，Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。
哨兵的作用就是监控redis主、从数据库是否正常运行，主出现故障自动将从数据库转换为主数据库。

它的功能包括以下两个。

1. 监控主数据库和从数据库是否正常运行。
2. 主数据库出现故障时自动将从数据库转换为主数据库。

#### 哨兵工作方式

1. 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。
2. 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）
3. 如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态
4. 当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）
5. 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。
6. 当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。
7. 若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。

主从切换过程：

1. slave leader升级为master
2. 其他slave修改为新master的slave
3. 客户端修改连接
4. 老的master如果重启成功，变为新master的slave

#### 哨兵模式的优缺点

优点:

- 哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。
- 主从可以切换，故障可以转移，系统可用性更好。
- 哨兵模式是主从模式的升级，系统更健壮，可用性更高。

缺点:

- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。
- 配置复杂

### 集群 cluster

即使使用哨兵，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据，浪费内存且有木桶效应。为了最大化利用内存，可以采用集群，就是分布式存储。

集群至少需要3主3从。每台redis存储不同的内容，分为16384个slot，每个redis实例分得一些slot，根据CRC16算法来取模得到所属的slot。
Redis 集群会把数据存在 master 节点，然后在这个 master 和其对应的 salve 之间进行数据同步。当读取数据时，也根据算法到对应的 master 节点获取数据。
只有当 master 挂掉之后，才会启动其对应的 salve 节点，充当 master 。存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。
PS，CRC16算法是什么？

Redis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，
每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点（包括主从）的连接，而且这些连接保持活跃，
这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。

![redis-cluster](https://raw.githubusercontent.com/yetao93/JavaNote/master/md_pic/redis-cluster.jpg "redis-cluster")

每一个节点都存有这个集群所有主节点以及从节点的信息。它们之间通过互相的ping-pong判断是否节点可以连接上。
如果有一半以上的Master节点去ping一个Master节点的时候没有回应，集群就认为这个Master节点宕机了，然后去连接它的Slave节点。
如果某个主节点和所有从节点全部挂掉，我们集群就进入fail状态。还有就是如果有一半以上的主节点宕机，那么我们集群同样进入fail状态。
这就是redis的投票机制。

## Redis 为什么是单线程的

## Redis、Memcache、MongoDB的区别

都是NoSQL数据库。
Redis、Memcache 比较相似，但与 MongoDB 完全不同，几乎没有可比性。
Redis/Memcache 是基于内存的，讲究的是性能，多用作缓存层。
MongoDB 是面向文档的，存储的是类似json的非结构化数据，查询方便，比较像关系型数据库。

数据结构
M：仅支持key-value类型。value最大只支持1MB
R：支持k-v、list、set、zset、hash等。value最大支持512MB

存储方式
M：把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小 。通过LRU算法抛弃最少使用的数据。
R：有部分存在硬盘上，支持数据的持久化！突破物理内存的限制。所有的key都在内存中，部分value会交换到磁盘。

底层模型
M：默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。
R：自己构建了VM机制，不调用系统函数

分布式可拓展性
M：在客户端中实现，通过一致性哈希之类的算法指定目标数据的节点
R：在服务端构建分布式存储，多节点，没有中心节点，各个节点地位一致，可伸缩。节点间通过二进制协议通信，与客户端通过ASCII协议通信。每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。

性能
M：多核，存储100K以上大数据性能较好。
R：单核，存储小数据性能较好。可以在服务端直接对数据操作，减少网络IO。

应用场景
M：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况。
R：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统。


## 缓存穿透、缓存击穿、缓存雪崩

## 缓存一致性