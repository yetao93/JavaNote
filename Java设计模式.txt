一、面向对象设计七个原则
		单一职责原则：它用于控制类的粒度大小。一个类只负责一个功能领域中的相应职责。就一个类而言，应该只有一个引起它变化的原因。
		
		接口隔离原则：当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的调用方仅需知道与之相关的方法即可。感觉跟单一职责原则有点像，一个是对类，一个是对接口。
									《敏捷软件开发》第12章——接口隔离原则(ISP)进行深入的学习。		
		
		开闭原则：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。
							具体操作，定义抽象层，再通过具体类来进行扩展，无须对抽象层进行任何改动。
		
		里氏代换原则：所有引用基类（父类）的地方必须能透明地使用其子类的对象。里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，
									因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
		
		依赖倒转原则：抽象不应该依赖于细节，细节应当依赖于抽象。要针对接口编程，而不是针对实现编程。要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，
									即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情
									
			在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。
		
		合成复用原则：尽量使用组合/聚合关系（关联关系），少用继承。
		
		迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。当其中某一个模块发生修改时，就会尽量少地影响其他模块。可降低系统的耦合度，使类与类之间保持松散的耦合关系。
		

二、设计模式的分类

总体来说设计模式分为三大类：

	创建型模式，共六种：简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

	结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

	行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

	其实还有两类：并发型模式和线程池模式。

简单工厂模式：
		包含以下几类角色，ConcreteFactory具体工厂角色、Product抽象产品角色、ConcreteProduct具体产品角色
		建立一个统一的工厂类作为工厂角色，其静态方法接收参数，根据参数的不同，创建具体产品角色，返回抽象角色，使用者以此来得到产品。
		
		缺点：工厂类过于庞大，职责重，包含大量if...else...代码
				  当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则“。

工厂方法模式：						 
		相较简单工厂，增加了一类角色，Factory抽象工厂角色。
		不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供实现了抽象工厂角色的不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。
		还可以隐藏产品方法，在工厂中直接调用了产品的业务，无需将产品返回给调用者。
		
		缺点：每个工厂只生产一类产品，当添加新产品时，需要同时添加对应的具体工厂类，系统中类的个数成对增加。
				  考虑到可扩展性，引入了抽象层，增加了系统的抽象性和理解难度。
		
抽象工厂模式：
		一个工厂可以创建一组对象。例如海尔工厂可以生产海尔洗衣机、海尔冰箱、海尔空调。这些产品就是一族，由同一个工厂生产。
		在抽象工厂中包含了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类。
		具体工厂实现了抽象工厂，其中的每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。
	   
		缺点：在抽象工厂中，增加新的产品族很简单，就像新增一个格力工厂，生产格力洗衣机冰箱空调。
					但是增加新的产品等级结构很麻烦，即很难在抽象工厂中增加工厂方法。抽象工厂这种性质称为开闭原则的倾斜性。

单例模式：
				特点1、单例类只能有一个实例。2、单例类必须自己创建自己的唯一实例，构造方法是私有的！。3、单例类必须给所有其他对象提供这一实例。
				优点1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。 2、避免对资源的多重占用（比如写文件操作）。
		单例模式的几种写法要熟悉，优缺点要知道，是否线程安全，是否延迟加载。
		1.懒汉式，getInstance()没有锁，线程不安全，延迟加载
		2.懒汉式，对getInstance()方法加锁synchronized，线程安全，延迟加载。但是效率低
		3.饿汉式，基于类加载机制避免了多线程同步问题，线程安全，非延迟加载。可能是调用getInstance以外的静态方法导致的加载，容易产生垃圾对象，浪费内存
		4.双检锁，对象用volatile修饰，在getInstance内第一次判断实例对象是否已经创建，若没有则对class对象加锁，第二次判断是否创建实例对象，若没有则创建它。线程安全，延迟加载。
		5.静态内部类，也是基于类的加载机制避免多线程同步问题，将实例对象的创建放到一个静态内部类中，只有调用getInstance才会加载这个静态内部类。线程安全，延迟加载。
		6.枚举类，只设置一个类型INSTANCE，然后添加方法。线程安全，延迟加载，反序列化也没问题。
		
		如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，
		那你就会有多个单例类的实例。解决办法是写一个readResolve()方法，返回该单例对象。

原型模式：
		使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。主要是对于模板（原型）的克隆。
		需要用到Object类的clone()方法，但是需要实现Cloneable空接口，重写clone()方法，调用super.clone()。这种方式是浅拷贝，对于引用对象，仍然是同一个。
		深拷贝可以使用序列化，所有对象都实现Serializable空接口，将其序列化再反序列化后，即是完全一样的两个对象。

建造者模式：
		是为了创建复杂对象。核心在于如何一步步构建一个包含多个组成部件的完整对象，使用相同的构建过程构建不同的产品。
		优点，(1) 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
				  (2) 每一个具体建造者都相对独立，而与其他的具体建造者无关。
				  (3) 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
		缺点：
				  (1) 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。
				  (2) 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。

适配器模式：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。主要分为三类，		
		类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。
		对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。
		接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。

装饰器模式：给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。
	一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。装饰类和被装饰类可以独立发展，
	不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

代理模式：为其他对象提供一种代理以控制对这个对象的访问。在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，
	有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，
	我们可以在访问此对象时加上一个对此对象的访问层。
		1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
		2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

		
		