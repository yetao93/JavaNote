一、设计模式的分类

总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

其实还有两类：并发型模式和线程池模式。

工厂方法模式：工厂方法模式分为三种
		1.普通工厂模式，就是建立一个工厂类，通过传入的不同参数，对实现了同一接口的一些类进行实例的创建
		2.多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。
		3.静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。
		总结：工厂模式适合凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。
			在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，
			我们会选用第三种——静态工厂方法模式。
		
抽象工厂模式：工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则。所以将工厂类写成接口，
	   创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，拓展性较好。
	   
单例模式：优点1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。 2、避免对资源的多重占用（比如写文件操作）。
		         特点1、单例类只能有一个实例。2、单例类必须自己创建自己的唯一实例，构造方法是私有的！。3、单例类必须给所有其他对象提供这一实例。
		单例模式的几种写法要熟悉，优缺点要知道，是否线程安全，是否延迟加载。
		1.懒汉式，线程不安全，延迟加载
		2.懒汉式，对getInstance()方法加锁synchronized，线程安全，延迟加载。但是效率低
		3.饿汉式，基于类加载机制避免了多线程同步问题，线程安全，非延迟加载。可能是调用getInstance以外的静态方法导致的加载，容易产生垃圾对象，浪费内存
		4.双检锁，对象用volatile修饰，在getInstance内第一次判断实例对象是否已经创建，若没有则对class对象加锁，第二次判断是否创建实例对象，若没有则创建它。线程安全，延迟加载。
		5.静态内部类，也是基于类的加载机制避免多线程同步问题，将实例对象的创建放到一个静态内部类中，只有调用getInstance才会加载这个静态内部类。线程安全，延迟加载。

		如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，
		那你就会有多个单例类的实例。解决办法是写一个readResolve()方法，返回该单例对象。

适配器模式：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。主要分为三类，		
		类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。
		对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。
		接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。

装饰器模式：给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。
	一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。装饰类和被装饰类可以独立发展，
	不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

代理模式：为其他对象提供一种代理以控制对这个对象的访问。在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，
	有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，
	我们可以在访问此对象时加上一个对此对象的访问层。
		1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
		2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

		
		