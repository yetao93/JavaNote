大概想法：RocketMQ（量好大啊，内容精深，下次再系统地学习）、dubbo、zookeeper

Q: 消息队列的功能，为什么使用消息队列？
A: 应用解耦。如果各个子系统间的耦合性太高，整体系统的可用性就会大幅降低，多个低错误率的子系统强耦合在一起，会得到高错误率的整体系统。
	流量消峰。面对突发的大流量，超出系统自身的处理能力，可以使用消息队列作为缓冲。
	消息分发。多个业务系统需要数据，生产方可以将数据写入消息队列，消费者根据各自的需求订阅即可。
	保证最终一致性，
	方便动态扩容，
	
Q: RocketMQ的特点
A: 支持事务型消息（消息发送和DB操作保持两方的最终一致性，rabbitmq和kafka不支持）
	支持结合rocketmq的多个系统之间数据最终一致性（多方事务，二方事务是前提）
	支持18个级别的延迟消息（rabbitmq和kafka不支持）
	支持指定次数和时间间隔的失败消息重发（kafka不支持，rabbitmq需要手动确认）
	支持consumer端tag过滤，减少不必要的网络传输（rabbitmq和kafka不支持）
	支持重复消费（rabbitmq不支持，kafka支持）

	缺点，
		Broker 仅提供了 Master 到 Slave 的复制，没有 Failover 切换的能力。
		没有告警与监控体系
	
Q: kafka的特点
A: Kafka 更偏向大数据，日志处理。
		缺少死信，消费失败自动重试，事务消息，定时消息，消息过滤，广播消息等特性，另外 Kafka 没有同步刷盘。

Q: RocketMQ各部分角色和功能
A: 由四部分组成
		1.发信者（Producer）
		2.收信者（Consumer）
		3.负责暂存、传输的邮局（Broker）
		4.负责协调各邮局的管理机构（NameServer），作用类似于注册中心。为什么不用zk，因为zk功能太多，这里用不到。

Q: mq生产者发送消息的策略有哪些？
A: 同步发送，
	异步发送，
	延迟发送，broker在接收到这类消息后，延迟一段时间再处理。
	事务消息，

Q: 消息发送的返回状态有哪些？
A: FLUSH_DISK_TIMEOUT，没有在规定的时间内完成刷盘（broker的刷盘策略被设置成SYNC_FLUSH才会报这个错）
	FLUSH_SLAVE_TIMEOUT，在主备方式下，并且broker设置为SYNC_MASTER时，没有在设定时间内完成主从同步
	SLAVE_NOT_AVAILABLE，在主备方式下，并且broker设置为SYNC_MASTER时，没有找到SLAVE
	SEND_OK，发送成功，具体消息是否已经储存到磁盘等要看刷盘策略、主从策略。

Q: Message Queue
A: 消息物理管理单位。
	一个Topic会有多个Message Queue，若Topic同时创建在不同的Broker，则不同的broker上都有若干Q，
	消息将物理地存储落在不同Broker结点上，具有水平扩展的能力。

	无论生产者还是消费者，实际的生产和消费都是针对Q级别。例如Producer发送消息的时候，会预先选择（默认轮询）好该Topic下面的某一条Q地发送；
	Consumer消费的时候也会负载均衡地分配若干个Q，只拉取对应Q的消息。

	每一条message queue均对应一个文件，这个文件存储了实际消息的索引信息。并且即使文件被删除，也能通过实际纯粹的消息文件（commit log）恢复回来。


Q: mq常用的消费模式有哪些，如何实现的呢？
A: Clustering      集群模式，同一个group下，只有一个消费者会消费一次。
			实际上每个消费者是平均分摊Message Queue去消费的，例如Topic有3个Queue，并且Consumer Group下有3个消费者，那么每个消费者一个Queue
			消费进度的存储会持久化到broker。
	
	Broadcasting 广播模式，同一个group下的所有消费者都会消费一次。
			实际上，是一个Consumer Group里每个消费者都获取到Topic下每个Message Queue去拉取消费。
			消费进度的存储会持久化到消费者实例本地。

Q: RocketMQ的消费者模型，特点是什么？会有什么问题？如何取舍？？
A: Pull 由用户控制线程，主动从服务端获取消息，每次获取到的是一个MessageQueue中的消息。
			优点，消费者可以根据自身能力拉取一定数量的消息进行消费。
			缺点，拉取消息的频率设定需要重点考虑，拉取间隔久会增加消息的延迟，MQ中消息堆积过多。拉取间隔短会产生很多无效的网络交互（	可通过长轮询解决）
			
	Push 由MQ主动将消息推送给消费者。 使用长轮询实现。
			优点，使用非常简单，内部已处理如线程池消费、流控、负载均衡、异常处理等等的各种场景。
			缺点，如果存在慢消费问题，MQ不断推送的消息会对消费者造成过大的压力，缓冲区溢出。

	RocketMQ通过Pull模式拉取消息，其中有长轮询机制，平衡推拉模型各自的缺点。如果一次拉取消息为空，并不直接返回，而是挂起请求，一段时间内有消息时再返回。

Q: RMQ的水平扩展及负载均衡
A: https://zhuanlan.zhihu.com/p/25140744

Q: 消息ACK机制及消费进度管理
A: https://zhuanlan.zhihu.com/p/25265380

Q: mq如何保证消息的可靠性？
A: 主从同步策略
	刷盘策略

Q: consumer消费失败后有什么补救措施？
A: 如果消费失败了，会把消息发回broker的 RETRY_TOPIC 队列，即重试队列，在延迟一定时间后再次投递。
	这样重复一定次数，默认16次，一直没有成功过，就投递到DLQ死信队列，需要人工处理。

Q: mq零拷贝？
A: RocketMQ主要通过内存映射技术MappedByteBuffer对文件进行读写操作。
	其中，利用了NIO中的FileChannel模型直接将磁盘上的物理文件直接映射到用户态的内存地址中
	（这种Mmap的方式减少了传统IO将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），
	将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率
	（这里需要注意的是，采用MappedByteBuffer这种内存映射的方式有几个限制，其中之一是一次只能映射1.5~2G 的文件至用户态的虚拟内存，
		这也是为何RocketMQ默认设置单个CommitLog日志数据文件为1G的原因了）。
		
	缺点：
		a.Mmap映射的内存空间释放的问题；由于映射的内存空间本身就不属于JVM的堆内存区（Java Heap），因此其不受JVM GC的控制，卸载这部分内存空间需要通过系统调用 unmap()方法来实现。然而unmap()方法是FileChannelImpl类里实现的私有方法，无法直接显示调用。RocketMQ中的做法是，通过Java反射的方式调用“sun.misc”包下的Cleaner类的clean()方法来释放映射占用的内存空间；
		b.MappedByteBuffer内存映射大小限制；因为其占用的是虚拟内存（非JVM的堆内存），大小不受JVM的-Xmx参数限制，但其大小也受到OS虚拟内存大小的限制。一般来说，一次只能映射1.5~2G 的文件至用户态的虚拟内存空间，这也是为何RocketMQ默认设置单个CommitLog日志数据文件为1G的原因了；
		c.使用MappedByteBuffe的其他问题；会存在内存占用率较高和文件关闭不确定性的问题；

Q: RocketMQ消息存储
A: 混合型存储结构，每个Broker实例下所有的队列共用一个日志数据文件CommitLog来存储。
	分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）。Consumer即可根据ConsumerQueue来查找待消费的消息。
			缺点是有较多的随机读操作，效率偏低。消费需要依赖ConsumeQueue，构建该逻辑队列需要一定的开销。
			
	ConsumeQueue 
		与MessageQueue一一对应。集群模式下多个消费者就可以并行消费Consume Queue的消息。
		作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的哈希值。
		存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，读性能很高近似内存。
								
	IndexFile           
		只是为了消息查询提供了一种通过key或时间区间来查询消息的方法。
	
	
Q: rocketMq的事务消息，有什么缺陷？
A: 采用两阶段提交的方式实现事务消息。
	1. 在业务操作事务提交前，发送消息到MQ服务端，此时消息状态为SEND_OK，但是消费者不可见。
	
	2. 提交业务操作的事务，如果成功，通知MQ服务端，将状态改为COMMIT_MESSAGE
		如果失败，将状态改为ROLLBACK_MESSAGE。注意这个通知可能会失败。
		
	3. MQ服务端有检查事务状态的服务，如果生产者通知失败了，则它会检测到消息状态未改过，通过生产者启动时注册的listener回调业务系统，
		查询业务操作的结果，并对消息状态进行对应的修改。
		
	缺点：一次消息发送需要两次请求。
			  业务系统需要实现消息状态回查功能。
			  消费失败，需要人工处理。

Q: rocketMq的顺序消息？
A: 是 MQ 提供的一种严格按照顺序进行发布和消费的消息类型。顺序消息由两个部分组成：顺序发布和顺序消费。
		顺序消息包含两种类型：
		分区顺序：一个Partition内所有的消息按照先进先出的顺序进行发布和消费
		全局顺序：一个Topic内所有的消息按照先进先出的顺序进行发布和消费。（对性能影响很大，基本不用）
		
	在MQ的模型中，顺序需要由3个阶段去保障：
		1. 消息被发送时保持顺序。
				用户应该在同一个线程中采用同步的方式发送。将消息路由到特定的分区，通过MessageQueueSelector来实现分区的选择

		2. 消息被存储时保持和发送的顺序一致，在同一个Message Queue中储存。
				存储时在空间上保持顺序。
				
		3. 消息被消费时保持和存储的顺序一致
				消息到达消费者后，必须按照顺序处理。	

Q: 如何自己实现mq？
A: TODO

Q: 说一下的 dubbo 的工作原理？
A: dubbo 分成哪些层，然后平时怎么发起 rpc 请求的，注册、发现、调用 TODO
	
Q: 注册中心挂了可以继续通信吗？
A: 可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。

Q: dubbo 支持哪些通信协议、序列化协议？
A: 通信协议
		dubbo协议，单一长连接，NIO异步通信，基于 hessian 作为序列化协议。适合传输数据量小（每次请求100kb以内），但是并发量很高。
		rmi协议，Java二进制序列化，多个短连接，适合消费者和提供者数量差不多的情况，适用于文件的传输，一般较少用。
		hessian 协议，hessian 序列化协议，多个短连接，适用于提供者数量比消费者数量还多的情况，适用于文件的传输，一般较少用。
		http 协议，json序列化
		webservice协议，SOAP 文本序列化。

Q: 说一下 hessian 的数据结构？
A: Hessian 的对象序列化机制有 8 种原始类型
			原始二进制数据
			boolean
			64-bit date（64 位毫秒值的日期）
			64-bit double
			32-bit int
			64-bit long
			null
			UTF-8 编码的 string
	还包括 3 种递归类型：
			list for lists and arrays
			map for maps and dictionaries
			object for objects
	还有一种特殊的类型：
			ref：用来表示对共享对象的引用。

Q: PB 知道吗？为什么 PB 的效率是最高的？
A: Protocol Buffer 是 Google 出品的一种轻量并且高效的结构化数据存储格式，性能比 JSON、XML 要高很多。
	性能如此好，主要得益于两个：第一，它使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 XML 和 JSON 快上了 20~100 倍；
			第二，它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。

Q: dubbo 负载均衡策略、高可用策略、动态代理策略 ？
A: 负载均衡策略见《项目系统设计》
	
	高可用策略（集群容错策略）
			failover cluster 模式，失败自动切换，自动重试其他机器，默认就是这个，常见于读操作。
			failfast cluster 模式，一次调用失败就立即失败，常见于非幂等性的写操作，比如新增一条记录，调用失败就立即失败。
			failsafe cluster 模式，出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。
			failback cluster 模式，失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。
			forking cluster 模式，并行调用多个 provider，只要一个成功就立即返回。常用于实时性要求比较高的读操作，但是会浪费更多的服务资源。
			broadcacst cluster，逐个调用所有的 provider。任何一个 provider 出错则报错，通常用于通知所有提供者更新缓存或日志等本地资源信息。
	
	动态代理策略
			默认使用 javassist 动态字节码生成，创建代理类。但是可以通过 spi 扩展机制配置自己的动态代理策略。

Q: dubbo 的 spi 思想是什么？
A: service provider interface
	TODO ，看样子就是面向接口编程

Q: 如何基于 dubbo 进行服务治理、服务降级、失败重试以及超时重试？
A: 服务治理
			1. 调用链路自动生成，各个服务之间的调用自动记录下来，将各个服务之间的依赖关系和调用链路生成出来
			2. 服务访问压力以及时长统计，自动统计各个接口和服务之间的调用次数以及访问延时。分成两个级别，
					2.1 第一个级别是接口粒度，就是每个服务的每个接口每天被调用多少次，延时多少。
					2.2 第二个级别是从源头入口开始，一个完整的请求链路经过几十个服务之后，完成一次请求，每天全链路走多少次，全链路请求延时多少。
					这样才能看到当前系统的压力主要在哪，如何扩容和优化。
			3. 服务分层（避免循环依赖）、调用链路失败监控和报警、服务鉴权、每个服务的可用性的监控

	失败重试和超时重试
			服务 A 调用服务 B 失败了，比如抛异常、连接超时、响应超时，此时根据异常类型决定是否同实例进行重试或者切换实例重试。
			
	服务降级
			服务 A 调用服务 B，结果服务 B 挂掉了，服务 A 重试几次调用服务 B，还是不行，那么直接降级，走一个备用的逻辑，给用户返回响应。
	

Q: 如何自己设计一个类似 dubbo 的 rpc 框架？
A: 考察的是对这类框架的原理是否了解。

	首先要有个注册中心，自己的服务注册上去，可以用zk来做。
	消费者去注册中心拿服务信息和对应的机器列表。
	消费者发起请求，基于动态代理，使用负载均衡算法找到一个机器
	使用netty发送，数据格式可以使用hessian序列化协议
	提供者也生成动态代理，监听网络端口，接收到请求时，调用对应的服务代码。

Q: zookeeper 都有哪些使用场景？
A: 分布式协调
			A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，
			A 系统立马就可以收到通知。

	分布式锁
			详见《系统项目设计》
			
	元数据/配置信息管理
			作为注册中心。
			
	HA高可用性
			重要进程做主备两个，主进程挂了立马通过zk感知到切换备用。
			主进程创建临时节点，备用注册监听器，如果主挂了，该临时节点会被删除，此时会发通知给备用进程，备用成为主进程，再次创建相同节点。
			
	感觉zookeeper的作用就两个，创建节点、注册监听器。

Q: zookeeper相关的知识点？
A: https://www.w3cschool.cn/zookeeper/zookeeper_overview.html


zookeeper 是什么？
zookeeper 都有哪些功能？
zookeeper 有几种部署模式？
zookeeper 怎么保证主从节点的状态同步？
集群中为什么要有主节点？
集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？
说一下 zookeeper 的通知机制？







