大概想法：并发源码、各种锁、线程安全

Q: Java代码的执行流程？
A: Java代码在编译后变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终转化为汇编指令在CPU上执行。

Q: CPU术语
A: 内存屏障是一组处理器指令，用于实现对内存操作的顺序限制。
	缓存行是CPU高速缓存中可以分配的最小存储单位。CPU高速缓存是指L1、L2之类CPU内部缓存。
	
Q: volatile的介绍、应用和底层实现？
A: volatile是轻量级的synchronized，它保证了共享变量的可见性，确保能够被准确和一致地更新。即当一个线程修改一个共享变量时，另一个线程能读到这个修改的值。
	具体实现是转成汇编代码后，指令多了lock前缀。
	lock前缀作用有两个，一是会将当前处理器缓存行的数据写回到系统内存。执行期间会有总线锁或缓存锁定，阻止同时修改由两个以上处理器缓存的内存数据。
									  二是这个写回操作会使其他CPU里的缓存该内存地址的数据失效。如需用到该数据，重新从系统内存中读取。

Q: Java对象头
A: 

Q: synchronized实现原理与应用
A: JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。代码块同步是使用monitorenter和monitorexit指令实现的，方法同步使用另一种方式，细节不明。
	这两个指令实在编译后插入到同步代码块的开始位置和方法结束处或异常处，必须一一配对。
	任何对象都有一个monitor与之关联，当该monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，就是尝试获取对象所对应的monitor所有权。
	
	synchronized用的锁存在Java对象头的Mark Word里。如果对象是数组类型，则对象头是3字宽，其他类型2字宽。在32位系统中，1字宽等于4字节。TODO

Q: 偏向锁和轻量级锁
A: 为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。锁一共有4中状态，无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。
	这几个状态会随着竞争情况逐渐升级，但不能降级。只升不降是为了提供获得锁和释放锁的效率。
	
	当一个线程获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步代码块时不需要进行CAS操作来加锁和解锁，只需要简单地
		测试一下对象头的Mark Word里是否存储指向当前线程的偏向锁。如果测试成功，表示线程已经获得锁。如果测试失败，则测试偏向锁标识是否为1（表示当前是
		偏向锁）。如果不是偏向锁，则使用CAS竞争锁。如果是偏向锁，则尝试使用CAS将对象头的偏向锁指向当前线程。
	偏向锁使用了一种等待竞争出现才释放锁的机制。当有其他线程尝试竞争偏向锁时，会在全局安全点暂停拥有偏向锁的线程，检查其是否活着，如果不处于活动状态，
		则将对象头设置为无锁。如果线程活着 TODO偏向锁撤销流程
	
	轻量级锁是指线程在执行同步代码块前将对象头中的Mark Word复制到线程栈帧中的锁记录空间，然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的
		指针，如果成功则当前线程获得锁，如果失败则表示其他线程竞争锁，当前线程尝试自旋来获取锁，即不断地进行CAS修改，一段时间后仍失败，
		则锁膨胀为重量级锁，线程进入阻塞状态。
	解锁时使用CAS操作将锁记录空间的内容替换回对象头，如果成功则表示没有竞争发生，如果失败表示有竞争，轻量级锁已经膨胀成重量级锁。释放锁并唤醒等待的线程。

Q: 锁的优缺点对比和适用场景
A: 偏向锁
			优点：加解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级差距。
			缺点：如果线程间存在竞争，会带来额外的锁撤销的消耗。
			适用：只有一个线程访问同步代码块的场景。
	轻量级锁
			优点：竞争的线程不会阻塞，提供了程序的相应速度。
			缺点：自旋消耗CPU
			适用：追求响应时间，同步代码块执行速度非常快
	重量级锁
			优点：无自旋，不消耗CPU
			缺点：线程阻塞，响应时间变长
			适用：追求吞吐量，同步代码块执行速度慢

Q: 原子操作
A: 处理器自身能够保证从系统内存中读写一个字节是原子的。对同一个缓存行里进行操作也是原子的。但是跨总线宽度、跨多个缓存行等需要其他机制来保证复杂的原子性。
	总线锁：当一个处理器在总线上输出LOCK信号时，其他处理器的请求将被阻塞，该处理器可以独占共享内存。其他处理器也不能操作其他内存地址的数据。
	缓存锁定：频繁使用的内存会缓存到L1、L2之类的高速缓存中，并且被LOCK锁定，当回写到内存时，修改内部的内存地址，并允许缓存一致性机制，
		阻止同时修改由两个以上处理器缓存的内存数据。当数据跨多个缓存行时，不适用。

Q: CAS算法
A: Compare and Swap，比较并交换，如果当前值与旧值相同，则替换成新值。

Q: 可重入锁有哪些？如何实现的可重入性？

Q: AQS的非公平和公平锁如何实现的？

Q: Volatile的可见性如何实现的？更新指令步骤是什么？

Q: cas是如何实现自旋的？语义是什么？它是悲观锁还是乐观锁？

Q: jmm模型描述一遍？

Q: 类的加载机制？类的初始化器有哪些？双亲委派方式？

Q: 死锁是什么，怎么办？
A: 1. 避免一个线程获取多个锁。2. 避免一个线程在锁内同时占用多个资源。3. 使用定时锁，lock.tryLock(timeout)来替代使用内部锁机制。

Q: 并发编程存在的问题？
A: 由于软硬件的资源限制，如网络、硬盘、CPU等，并发的代码可能仍在串行执行，这时程序不仅不会加快反而更慢，因为增加了上下文切换和资源调度的时间。

Q: 如何解决并发编程的问题？
A: 对于硬件资源限制，既然单机有上限，可以使用集群并行执行程序，通过负载均衡算法，让多个服务器处理数据。
    对于软件资源限制，可以考虑使用资源池进行复用。