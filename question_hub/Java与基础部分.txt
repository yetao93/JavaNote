大概想法：并发源码、各种锁、线程安全

Q: 并发编程存在的问题？
A: 由于软硬件的资源限制，如网络、硬盘、CPU等，并发的代码可能仍在串行执行，这时程序不仅不会加快反而更慢，因为增加了上下文切换和资源调度的时间。

Q: 如何解决并发编程的问题？
A: 对于硬件资源限制，既然单机有上限，可以使用集群并行执行程序，通过负载均衡算法，让多个服务器处理数据。
    对于软件资源限制，可以考虑使用资源池进行复用。

Q: Java代码的执行流程？
A: Java代码在编译后变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终转化为汇编指令在CPU上执行。

Q: 内存屏障，缓存行
A: 内存屏障是一组处理器指令，用于实现对内存操作的顺序限制。
	缓存行是CPU高速缓存中可以分配的最小存储单位。CPU高速缓存是指L1、L2之类CPU内部缓存。
	
Q: volatile的介绍、应用和底层实现？
A: volatile是轻量级的synchronized，它保证了共享变量的可见性，确保能够被准确和一致地更新。即当一个线程修改一个共享变量时，另一个线程能读到这个修改的值。
	具体实现是生成字节码时会在指令序列中插入内存屏障。转成汇编代码后，指令多了lock前缀。对volatile变量的读写具有原子性，但复合操作不具有原子性。
	lock前缀作用有两个，一是会将当前处理器缓存行的数据写回到系统内存。执行期间会有总线锁或缓存锁定，阻止同时修改由两个以上处理器缓存的内存数据。
									  二是这个写回操作会使其他CPU里的缓存该内存地址的数据失效。如需用到该数据，重新从系统内存中读取。

	volatile内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。
								 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，接下来将从主内存中读取共享变量。

Q: 双检锁中为什么instance使用volatile修饰
A: 为了防止重排序，初始化一个实例在字节码中有4步，1.申请内存空间，2.初始化默认值，3.执行构造方法，4.连接引用和实例。
	其中后两步可能会重排序，造成未完成构造的对象发布。使用volatile禁止指令重排序，避免这个问题。
	因为在volatile写操作之前任何操作都是不可重排序的。

Q: Volatile的可见性如何实现的？更新指令步骤是什么？

Q: Java对象头

Q: synchronized实现原理与应用
A: JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。代码块同步是使用monitorenter和monitorexit指令实现的，方法同步依靠方法修饰符上的ACC_SYNCHRONIZED来完成。
	这两个指令实在编译后插入到同步代码块的开始位置和方法结束处或异常处，必须一一配对。
	任何对象都有一个monitor与之关联，当该monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，就是尝试获取对象所对应的monitor所有权。
	
	synchronized用的锁存在Java对象头的Mark Word里。如果对象是数组类型，则对象头是3字宽，其他类型2字宽。在32位系统中，1字宽等于4字节。TODO

Q: 偏向锁和轻量级锁
A: 为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。锁一共有4中状态，无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。
	这几个状态会随着竞争情况逐渐升级，但不能降级。只升不降是为了提供获得锁和释放锁的效率。
	
	当一个线程获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步代码块时不需要进行CAS操作来加锁和解锁，只需要简单地
		测试一下对象头的Mark Word里是否存储指向当前线程的偏向锁。如果测试成功，表示线程已经获得锁。如果测试失败，则测试偏向锁标识是否为1（表示当前是
		偏向锁）。如果不是偏向锁，则使用CAS竞争锁。如果是偏向锁，则尝试使用CAS将对象头的偏向锁指向当前线程。
	偏向锁使用了一种等待竞争出现才释放锁的机制。当有其他线程尝试竞争偏向锁时，会在全局安全点暂停拥有偏向锁的线程，检查其是否活着，如果不处于活动状态，
		则将对象头设置为无锁。如果线程活着 TODO偏向锁撤销流程
	
	轻量级锁是指线程在执行同步代码块前将对象头中的Mark Word复制到线程栈帧中的锁记录空间，然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的
		指针，如果成功则当前线程获得锁，如果失败则表示其他线程竞争锁，当前线程尝试自旋来获取锁，即不断地进行CAS修改，一段时间后仍失败，
		则锁膨胀为重量级锁，线程进入阻塞状态。
	解锁时使用CAS操作将锁记录空间的内容替换回对象头，如果成功则表示没有竞争发生，如果失败表示有竞争，轻量级锁已经膨胀成重量级锁。释放锁并唤醒等待的线程。

Q: 锁的内存语义
A: 当线程释放锁时，JMM会把线程对应的本地内存中的共享变量刷新到主内存中，
	当线程获取锁时，JMM会把线程对应的本地内存置为无效，从而使得必须从主内存中读取共享变量。
	线程A释放锁，线程B获得锁，实质上是线程A通过主内存向线程B发送消息。

Q: 锁的优缺点对比和适用场景
A: 偏向锁
			优点：加解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级差距。
			缺点：如果线程间存在竞争，会带来额外的锁撤销的消耗。
			适用：只有一个线程访问同步代码块的场景。
	轻量级锁
			优点：竞争的线程不会阻塞，提供了程序的相应速度。
			缺点：自旋消耗CPU
			适用：追求响应时间，同步代码块执行速度非常快
	重量级锁
			优点：无自旋，不消耗CPU
			缺点：线程阻塞，响应时间变长
			适用：追求吞吐量，同步代码块执行速度慢

Q: 原子操作
A: 处理器自身能够保证从系统内存中读写一个字节是原子的。对同一个缓存行里进行操作也是原子的。但是跨总线宽度、跨多个缓存行等需要其他机制来保证复杂的原子性。
	总线锁：当一个处理器在总线上输出LOCK信号时，其他处理器的请求将被阻塞，该处理器可以独占共享内存。其他处理器也不能操作其他内存地址的数据。
	缓存锁定：频繁使用的内存会缓存到L1、L2之类的高速缓存中，并且被LOCK锁定，当回写到内存时，修改内部的内存地址，并允许缓存一致性机制，
		阻止同时修改由两个以上处理器缓存的内存数据。当数据跨多个缓存行时，不适用。

Q: CAS算法
A: Compare and Swap，比较并交换，如果当前值与旧值相同，则替换成新值。
	使用Unsafe类的native方法compareAndSwap来做
	会为CPU指令加上lock前缀，CAS同时具有volatile读和写的内存语义。

Q: 可重入锁有哪些？如何实现的可重入性？

Q: 队列同步器AQS
A: 是用来构建锁或者其他同步组件的框架，它使用了一个int变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。
	大大降低了实现一个可靠的自定义同步组件的门槛（即自己实现一个锁）。

Q: AQS的非公平和公平锁如何实现的？AbstractQueuedSynchronizer
A: AQS使用一个整型的volatile变量state来维护同步状态
	内存语义，公平锁和非公平锁释放时，最后都要改变state值。公平锁获取时，首先会去读state。非公平锁获取时，首先会用CAS更新volatile。

Q: cas是如何实现自旋的？语义是什么？它是悲观锁还是乐观锁？

Q: final域的内存语义，重排序规则
A: 1.在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给变量，这两个操作之间不能重排序。确保在对象引用为其他线程可见之前，
		对象的final域已经被正确初始化过了，而普通域不具有这个保障。
	2.在一个线程中，初次读对象引用与初次读该对象所包含的final域，JMM禁止处理器重排序这两个操作。编译器本就不会重排序这两个操作，因为它们有间接依赖关系。

Q: Java内存模型JMM介绍
A: 线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程已读写共享变量的副本。
	线程A要与线程B通信，必须把本地内存A中更新过的共享变量刷新到主内存中，然后线程B到主内存中读取它。

Q: 指令重排序
A: 在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。共分3种：
		1.编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
		2.指令级并行的重排序。现代处理器的并行技术。
		3.内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作可能是乱序执行的。

	重排序可能导致多线程程序出现内存可见性问题。对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，使用内存屏障来禁止。
	
Q: happens-before
A: 在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。
	如果重排序之后的执行结果与原来一致，那么这种重排序是允许的。
	happens-before有许多规则，一个规则对应一个或多个编译器和处理器重排序规则。它避免了程序员去学习复杂的重排序规则以及具体实现。
	
Q: as-if-serial 语义
A: 不管怎么重排序，单线程程序的执行结果不能被改变。
	为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。单线程中对控制依赖的操作重排序，不会改变执行结果，但是多线程会。

	as-if-serial是针对单线程程序，happens-before是针对正确同步的多线程程序，在不改变结果的前提下，尽可能地提高程序执行的并行度。

Q: 类的加载机制？类的初始化器有哪些？双亲委派方式？

Q: 死锁是什么，怎么办？
A: 1. 避免一个线程获取多个锁。2. 避免一个线程在锁内同时占用多个资源。3. 使用定时锁，lock.tryLock(timeout)来替代使用内部锁机制。


	
