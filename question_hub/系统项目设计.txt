大概想法：分布式项目，自身做过的项目

Q: CAP 定理
A: Consistency
		一致性，更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致。例如客户端向服务A1写入x，会向A2同步数据，再向服务A2读取该值，获得的也是x，就是一致性。
	Availability
		可用性，服务一直可用，而且是正常响应时间。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。
	Partition Tolerance 
		分区容错，分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务，不会挂掉。

	为什么不能同时满足：因为网络是不可靠的，如果发生故障导致节点间无法同步数据，那么强一致性和可用性只能二选一。

	CA：不要求分区，则强一致性和可用性是可以保证的。但分布式是前提，放弃分区意味着放弃了系统的扩展性，不再部署子节点，这违背分布式系统设计的初衷。
	CP：不要求可用，每个请求在服务器直接保持强一致，如果发生网络故障或消息丢失，就要牺牲用户体验，等所有数据同步之后再让用户访问系统。
	AP：不要求一致，在发生故障节点无法同步数据时，每个节点都只能用本地数据提供服务，导致全局数据不一致。

Q: BASE 理论
A: 是对CAP理论的延伸，思想是即使无法做到强一致性（CAP的一致性就是强一致性），但可以采用适当的采取弱一致性，即最终一致性。
	BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。
	基本可用
			基本可用是指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、功能上的可用性），允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。
			响应时间上的损失：正常情况下搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。
			功能上的损失：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。
	软状态
			软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。
	最终一致性
			最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。			

Q: 分布式项目如何保证单个模块的高可用？
A: 分为 3 个步骤，故障发现、故障消除、故障善后。
	故障发现：
			1. 监控：
					进程外，运用 Zabbix 之类的无探针解决方案，调用系统或者服务自身提供的状态接口获取采集数据。优点无侵入。
									但弊端是监控的粒度太粗，只能进行一些外在的监控。比如可以发现 CPU 突然飙高了，但是并不知道可疑的接口是哪个，更无法知道是哪行代码导致的问题。
					进程内，直接引入采集 SDK 然后硬编码在源代码、通过 AOP 框架来进行动态代码注入。还可以通过利用整个系统中的“连接”部分来进行，比如一些中间件。
									缺点需要侵入到应用程序内部，所以对性能和稳定性会带来一定的影响。
			2.故障注入测试：
					通过技术手段来主动制造“故障”，以此来提前检验系统在各种故障场景下的表现情况是否符合我们预期。
					故障可以被注入到软件，也可以被注入到硬件。
						注入到软件，1. 架设在软件与操作系统之间，当软件中的数据经过操作系统时，通过篡改数据完成注入。
											2. 通过 AOP 之类的框架进行代码注入来制造故障。
						注入到硬件，直接运行一段代码把 CPU、网卡等吃满即可。

	故障消除：
			通过综合运用隔离性、横向扩展、代理、负载均衡、熔断、限流、降级等等机制来快速的“掐灭故障”，防止雪崩的发生。
			
	故障善后：
			故障产生的原因要么是调用的节点处于异常状态，要么是通信链路异常。
			两个进程之间的调用方式。一是直接点对点的同步调用，或者是通过一些技术中间层进行异步的调用。
			1. 同步调用
					1.1 重试，副作用是，如果后端服务总体负载很高，且无法自动弹性扩容，那么会进一步加剧一些压力。
					1.2 将可以容忍最终一致性的同步调用产生的出错消息进行异步重发。比如产生订单的服务有问题，可以先存到消息队列中，再进行异步投递。
			2. 异步调用
					最常见的就是发往消息队列出现异常，通过定时的任务（job）去进行对账（数据一致性检测）。任务（job）的具体实现上尽可能做到自动修正，否则通知人工介入。

Q: 做的最好的项目是什么，有什么特色？

Q: 分布式事务的实现方案有哪些？如果让你自己设计，你应该怎么设计？

Q: 负载均衡的算法有哪些？
A: 常见的负载均衡算法包括轮询法、随机法、加权轮询法、加权随机法、源地址哈希法、最小连接法等，应根据具体的使用场景选取对应的算法。

Q: 一致性哈希是什么，虚拟节点？
A: 常用于分布式缓存系统。普通的哈希取余算法，容错性和扩展性不好，如果增加/删除了机器，会有大量数据失效或需要转移。
	一个设计良好的分布式哈希方案应当具有良好的单调性，即服务节点的增减不会造成大量哈希重定位。单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，
			又有新的缓冲加入到系统中，哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。
	
	一致性哈希算法就是这样一种哈希方案。常用于负载均衡。可以取代传统的取模操作。
	一致性哈希将整个哈希值空间组织成一个虚拟的圆环，将服务器按特定的算法计算出其在圆环的位置，对数据key也使用相同算法计算出位置，然后按顺时针
			行走，第一台遇到的服务器就是其定位到的服务器。
	
	容错性与扩展性分析：
			如果一台机器宕机了，原本属于其他机器处理的数据不受影响，该宕机服务器该处理的数据会交到下一台机器。
			如果增加了一台机器，受影响的数据仅仅是其到前一台机器之间的数据，其他不会受影响。
		最大限度抑制了hash键的重新分布。
			
	虚拟节点：
			一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。例如只有两台机器，一台处理了90%数据，另一台只处理10%。
			所以引入虚拟节点的概念，对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。
			当配置了几百个虚拟节点时，就能抑制分布不均匀。
			
	// TODO 一致性哈希的具体实现

Q: 熔断是什么？实现方式有哪些？

Q: 限流算法有哪些？它们的优点和缺点？

Q: 分布式锁
A: 分布式锁需满足四个条件：
		1. 互斥性。在任意时刻，只有一个客户端能持有锁。
		2. 超时自动释放。不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。
		3. 只有自己才能释放锁。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了，即不能误解锁。
		4. 具有容错性。只要大多数Redis节点正常运行，客户端就能够获取和释放锁。
		
	有三种常见的实现方式：1. 数据库乐观锁、2.基于Redis的分布式锁、3.基于ZooKeeper的分布式锁。
	
	用Redis实现分布式锁（实现一）：使用Jedis
		原子性加锁
			jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);
			通过判断value是否与自身相同可实现重入性

			不使用value=过期时间的原因是 
				1. 需要强制要求分布式下每个客户端时间必须同步
				2.当锁过期的时候，如果多个客户端同时执行jedis.getSet()方法，那么虽然最终只有一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖。
				3. 锁不具备拥有者标识，即任何客户端都可以解锁。

		原子性解锁 
			String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
			Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));
			写了一段lua脚本，保证原子性执行。获取原值判断与requestId是否相同，若相同则解锁。

		该方案满足前三个条件。但是在Redis集群环境下依然存在问题，由于Redis集群数据同步为异步，假设在Master节点获取到锁后未完成数据同步情况下Master节点宕掉，
				主从切换，一个slave节点成为新的Master节点，依然可以获取锁，所以多个Client同时获取到了锁。
		并且过期时间设置不能太短，如果在业务执行完之前锁就过期，会造成多个Client同时获取到了锁。

	用Redis实现分布式锁（实现二）：Redisson RedissonLock
		使用Redisson实现的分布式可重入锁，比自己手动写的效果好，基本原理相同。也都没有解决Master节点挂了之后锁丢失的风险。
		
		
	用Redis实现分布式锁（实现三）：Redisson RedLock
		解决了单点失败的问题，但代价是需要额外的为 RedissonRedLock 搭建Redis环境。
		// TODO 具体的RedLock原理

Q: 服务缓存、降级、健康检查、故障转移、主备模式