Hibernate的作用，目前主流的数据库是关系数据库，而Java语音则是面向对象的编程语言，二者结合相当麻烦，
Hibernate减少了这个问题的困扰，它使得开发者可以完全采用面向对象的方式来开发应用程序。Hibernate相当于桥梁，
允许程序员采用面向对象的方式来操作关系数据库。

ORM（Object/Relation Mapping）对象/关系数据库映射。其中非常重要的一个媒介 —— PO

PO （Persistent Object） 持久化对象，完成持久化操作，通过该对象可对数据执行增、删、改，是以面向对象的方式操作数据库
应用程序与数据库没有直接联系，只需创建、修改、删除持久化对象即可，与此同时，Hibernate负责把这种操作转换为对数据表的操作

POJO （普通、传统的Java对象，类似JavaBean）持久化类
Hibernate被称为低侵入式设计的原因是其直接采用了POJO作为PO，不继承父类不实现接口不被污染

普通的JavaBean还不具备持久化操作的能力，所以要添加一些注解或经过XML文件配置。
PO = POJO + 持久化注解

在JavaBean里添加注解，修改hibernate.cfg.xml里的<mapping class="包名.类名">，不用加.java

完成消息插入的工作，一个java类，PO只有在Session的管理下才可完成数据库的访问。步骤：1.开发持久化类 2.获取Configuration 
3.获取SessionFactory 4.获取Session 打开事务 5.用面向对象的方式操作数据库 6.关闭事务，关闭Session

Hibernate两个显著优点：不再需要编写SQL语句，允许采用OO方式来访问数据库。
		       JDBC访问过程中大量的checked异常被包装成Hibernate的Runtime异常，不再要求程序必须处理所有异常。


Hibernate持久化对象的三个对象状态：	改变状态的方法在下面

	瞬态——对象由new操作符创建，且尚未与Hibernate Session关联的对象被认为处于瞬态。瞬态对象不会被持久化到数据库中，也不会被赋予持久化标识。如果程序失去瞬态对象的引用，瞬态对象将被垃圾回收机制销毁。
        
      持久化——持久化实例在数据库中有对应的记录，并拥有一个持久化标识(identifier)，持久化实例可以是刚刚保存的，也可以是刚被加载的但都必须与制定的Hibernate Session关联。Hibernate会检测到处于持久化状态对象的改动，在当前操作执行完成时将对象数据写		回数据库，开发者不需要手动执行UPDATE

	托管——某个实例曾经处于持久化状态，但随着与之关联的Session被关闭，该对象就变成托管状态。托管对象的引用依然有效，对象可继续被修改。如果重新与某个Session关联，会重新转换为持久化状态，而托管期间的改动也不会丢失，也可被写入数据库



深入Hibernate的配置文件

创建Configuration对象，根据配置文件不同，创建方式也不同，常用hibernate.cfg.xml作配置文件，其中已添加了Hibernate映射文件，可通过Configuration cfg = new Configuration().configue();实现，configure()方法负责加载hibernate.cfg.sml文件

JDBC连接属性：hibernate.connection.driver_class	设置连接数据库的驱动
	      hibernate.connection.url		设置所需连接数据库服务的URL
	      hibernate.connection.username	连接数据库的用户名
	      hibernate.connection.password	密码
	      hibernate.dialect			设置连接数据库所使用的方言
	      hibernate.connection.pool_size	设置Hibernate数据库连接池最大并发连接数

	但Hibernate自带的连接池仅有测试价值，实际项目推荐使用C3P0或Proxool连接池代替
	      hibernate.c3p0.max_size		C3P0连接池的最大连接数
	      hibernate.c3p0.min_size		最小连接数
	      hibernate.c3p0.timeout		连接的超时时长
   	      hibernate.c3p0.max_statements	缓存Statement的数量

	数据库方言：Hibernate底层依然使用SQL语句来执行数据库操作，但不同数据库在语法细节上存在一些差异，通过设置方言来应付差异。
	      	      

JNDI数据源的连接属性：如果无须Hibernate自己管理数据源，而是直接访问容器Tomcat管理数据源，可使用JNDI数据源的相关配置，也要配置方言
	      hibernate.connection.datasource	指定数据源JNDI名字
	      hibernate.jndi.url		指定JNDI提供者的URL，可选
	      hibernate.jndi.class		指定JNDI InitialContextFactory的实现类，可选
	      			用户名、密码也是可选，方言


Hibernate事务属性：hibernate.transaction.factory_class	指定所有事务工厂的类型，必须是TransactionFactory的直接或间接子类

		   jta.UserTransaction	一个JNDI名，Hi使用JTATransactionFactory从应用服务器获取JTA UserTransaction

		   hibernate.transaction.manager_lookup_class	

		   hibernate.transaction.flush_before_completion  指定Session是否在事务完成后自动将数据刷新到底层数据库
		   hibernate.transaction.auto_close_session
		   指定是否在事务结束后自动关闭Session，以上两个用Context相关的Session管理更好

二级缓存：SessionFactory可持有一个可选的二级缓存，可提供Hibernate的持久化访问的性能

   相关属性	  hibernate.cache.provider_class	设置二级缓存CacheProvider的类名
		  
		  hibernate.cache.use_minimal_puts	以频繁的读操作为代价，优化二级缓存以实现最小化写操作

		  hibernate.cache.user_query_cache	设置是否允许查询缓存
	
		  hibernate.cache.user_second_level_cache  设置是否启用二级缓存

		  hibernate.cache.query_cache_factory	设置查询缓存工厂的类名，必须实现QueryCache接口
		
		  hibernate.cache.region_prefix		设置二级缓存区名称的前缀

		  hibernate.cache.use_structured_entries设置是否强制Hibernate以可读性更好的格式将数据存入二级缓存

外链接抓取属性：hibernate.max_fetch_depth	0为禁止，1或更高值启用
		外链接抓取能限制执行SQL语句的次数来提高效率，通过在单个select语句中使用outer join来一次抓取多个数据表的数据

其他常用配置属性：
	hibernate.show_sql	是否在控制台输出Hibernate生产的SQL语句，true or false

	hibernate.format_sql	是否将SQL语句转成格式良好的SQL，true or false

	hibernate.use_sql_comments	是否在SQL中添加注释

	hibernate.jdbc.fetch_size	指定JDBC抓取数量的大小，整数值，实质是调用Statement.setFetchSize()

	hibernate.jdbc.batch_size	指定Hibernate使用JDBC2的批量更新的大小，整数值，建议5-30

	hibernate.connection.autocommit	设置是否自动提交，通常不建议打开
	
	hibernate.hbm2ddl.auto	设置当创建SessionFactory时，是否根据映射文件自动建立数据库表，update,create,create-drop		


持久化类的要求：1.提供一个无参的构造器	
		2.提供一个标识属性，可无，通常映射数据库表的主键字段，基本类型建议使用包装类型  
		3.建议使用可以为空的类型来作为标识属性的类型，因此尽量避免使用基本数据类型
		4.为持久化类的每个属性提供setter和getter方法	
		5.使用非final类，同时避免public final的方法不然需设置lazy=false
		6.关于重写equals()和hashCode()方法，不懂，P398


改变持久化对象	Serializable save(Object obj)	将obj对象变为持久化状态，该对象的属性将被保存到数据库
状态的方法：	void persist(Object obj)	同上
		Serializable save(Object obj,Object pk) 同上，并指定主键值
		void persist(Object obj,Object pk) 同上
		详见P386
	在把一个瞬态实体变成持久化状态时，Hibernate会在底层对应地生成一条insert语句，把实体对应的数据插入数据表
	
对于脱管状态的对象，可以使用一下方法来保存修改
	update()	保存生效对持久化对象所做的修改，使对象变成持久化状态
	updateOrSave()	自动判断对象是否曾经持久化，如果曾经持久化过，就使用update，否则sace
	merge()		同update，区别是merge不会持久化给定对象，对象依然不是持久化状态
	


    可将集合分成两类：
	有序集合：集合里的元素可以根据key或index访问。拥有一个由外键列和集合元素索引列自称的联合主键，性能高
	无序集合：集合里的元素只能遍历。例如Set的主键由<key>和其他元素字段构成，或根本没有主键

	数组虽然也是有序集合，但无法使用延迟加载，因为长度不可变，性能不高，通常List、Map集合性能较高，Set紧随其后
		

映射组件属性(不是基本数据类型，不是String，比如 类)
	使用<component>元素，name属性指定组件属性的名称
			 
